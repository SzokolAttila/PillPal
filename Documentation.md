# PillPal Documentation

## Summary
Most elderly people faces the difficulties of managing vast variety of medicines, creating the proper schedule for them, keep in mind all the descriptions and not to forget taking them. That's the problem we are aiming to solve or at least provide a tool to make it easier.
Our solution consists of a WebAPI, a Class Library, a MAUI App and a WebApplication. In the following we are going to break them down into smaller segments and introduce their details.

## Class Library
### User
User class consists of Id, Username and Password properties. Our password is a byte array which is generated by hashing the string type password given via constructor. For hashing we're using a unique salt so it gives more security. User class also has a Matches(string password) function for checking if the given password is the same as the user's byte[] password after hashing. We've made 3 constructors: one for logging in, one for JsonConstructor and one for the controller for registering a new user.
### Medicine
Medicine class consists of Id, Name, Description, Manufacturer, PackageUnit, PackageSizes, SideEffects, ActiveIngredients and RemedyForAilments properties. PackageUnit stores the unit of the medicine's PackageSizes which is either "ml" or "mg". PackageSizes, SideEffects, ActiveIngredients and RemedyForAilments are multi-valued fields so they have a separate table and joined together with medicine. Medicine class has 2 constructors: one JsonConstructor with id and one constructor without id. Multi-valued fields are set from outside and not from constructor.
### Reminder
Reminder table is a join-table itself so its class behaves the same way. It has the following properties: Id, UserId, User, MedicineId, Medicine, When, DoseCount, DoseMg, TakingMethod. User and Medicine properties are nullable as they're set from outside based on UserId and MedicineId. DoseCount stores the quantity to take in and TakingMethod stores how to take it in. 
### ExceptionHandler
Our main issue with HttpResponseMessage is that we have a wide range of different structures for different error messages. We created a CheckHttpResponse(HttpResponseMessage message) static method which handles each HttpResponseMessage properly and throws an ArgumentException with the proper error message if the request failed for any reasons. With this static method we can easily handle any error message generally.

### API handlers
For handling different request towards the API from the backend we created API handlers to make it easier and avoid code repeating. They also handle different occuring issues and throws exception with the proper error message.

#### APIHandlerBase
This class serves as a base class for APIHandlers, and thus they are all derived from this class. It includes the HttpClient and JsonSerializerOptions as protected fields, and the constructor (that is the same for every APIHandler class). This reduces code repetition and makes it easier to work with these classes.

#### MedicineAPIHandler
Through constructor base url and HttpClient can be passed to make testing easier for us. If HttpClient is not given then it is created with the base url.
Methods: 
- **GetMedicine(int id)** method which gives back the medicine with the given id. And throws exception if something goes wrong.
- **GetMedicines()** method returns all the medicines. Throws exception in case of any issue.
- **CreateMedicine(MedicineDto medicine, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin to access posting; Then posts the serialized Medicine object. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **UpdateMedicine(int id, MedicineDto medicine, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin to access putting; Then puts the serialized Medicine object to the given id. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **DeleteMedicine(int id, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin to access deleting; Then deletes the medicine with the given id. In case of any issues function throws exception (usually it somehow connects to authorization).
#### ReminderAPIHandler
Through constructor base url and HttpClient can be passed to make testing easier for us. If HttpClient is not given then it is created with the base url.
Methods: 
- **Get(int id, string auth)** method sets authorization in header, then gives back all reminders for the user with the given id. Needs authentication as a user can only access their own reminders. And throws exception if something goes wrong (usually connected to authorization).
- **GetAll(string auth)** method sets authorization in header, then returns all reminders. Needs admin authentication as users' reminders are sensitive data. Throws exception in case of any issue (usually connected to authorization).
- **CreateReminder(ReminderDto reminder, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user who the reminder belongs to for access of posting; Then posts the serialized Reminder object. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **EditReminder(int id, RemiderDto reminder, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user who the reminder belongs to for access of putting; Then puts the serialized Reminder object to the user with given id. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **DeleteMedicine(int id, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user who the reminder belongs to for access of deleting; Then deletes the reminder with the given id. In case of any issues function throws exception (usually it somehow connects to authorization).
#### UserAPIHandler
Through constructor base url and HttpClient can be passed to make testing easier for us. If HttpClient is not given then it is created with the base url.
Methods: 
- **Login(CreateUserDto user)** method which posts a login with the given username and password, then returns the bearer token on success.
- **GetUser(int id, string auth)** method sets given authentication in header as you need to be admin or the user themself who's data is accessed. Returns the user with the given id. Throws error if something goes wrong with the request. 
- **GetUsers(string auth)** method sets given authentication in header as you need to be admin to access all users. Returns all users' data. Throws exception in case of any issue.
- **CreateUser(CreateUserDto user)** void method posts the serialized User object, this way user can registrate a new account. In case of any issues function throws exception (usually it somehow connects to validation).
- **UpdateUser(int id, CreateUserDto user, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user themself to access putting; Then puts the serialized User object to the given id. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **DeleteUser(int id, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user themself to access deleting; Then deletes the user with the given id. In case of any issues function throws exception (usually it somehow connects to authorization).

#### PackageSizeAPIHandler
Derived from APIHandlerBase class and uses its constructor to initialize fields.
Methods:
- **GetAll()** requires no authorization and returns an IEnumerable of every PackageSize added to the database, regardless of which medicine it was added to. 
- **Get(int id)** requires no authorization and returns an IEnumerable of PackageSizes based on the id passed (it filters based on medicineId)
- **CreatePackageSize(CreatePackageSizeDto createDto, string token)** requires admin token to post a PackageSize to the database. Throws an argument exception in case any data given is not appropriate (if the Dto didn't pass the validation test, the user is not authorized or the medicine doesn't exist).
- **EditPackageSize(int id, CreatePackageSizeDto createDto, string token)** requires admin token to update an existing PackageSize in the database. Throws an exception if the PackageSize doesn't exist, the user is not authorized or if any other issue comes up. 
- **DeletePackageSize(int id, string token)** requires admin token to delete an existing PackageSize from the database. Throws an argument exception if anything goes wrong.

#### SideEffectAPIHandler
Derived from APIHandlerBase class and uses its constructor to initialize fields.
Methods:
- **GetAll()** requires no authorization and returns an IEnumerable of every SideEffect added to the database.
- **Get(int id)** requires no authorization and returns a single SideEffect from the database that has the given id. If it doesn't exist, it throws an argument exception with the "Not Found" message.
- **CreateSideEffect(CreateSideEffectDto createDto, string token)** requires admin role to post a SideEffect to the database. If any issues come up (such as validation problems) the function throws an argument exception.
- **EditSideEffect(int id, CreateSideEffectDto createDto, string token)** requires admin role to update an existing SideEffect in the database. Throws an excetpion if the SideEffect doesn't exist, the user is not authorized or if any other issue comes up.
- **DeleteSideEffect(int id, string token)** requires admin role to delete an existing SideEffect from the database. Throws an argument exception if anything goes amiss.

#### MedicineSideEffectAPIHandler
Derived from APIHandlerBase class and uses its constructor.
Methods: 
- **GetAll()** requires no authorization and returns an IEnumerable of every MedicineSideEffect added to the database, regardless of which medicine it belongs to.
- **Get(int id)** requires no authorization and returns an IEnumerable of every MedicineSideEffect that belongs to the medicine with the given id.
- **CreateMedicineSideEffect(CreateMedicineSideEffect createDto, string token)** requires admin role to post a MedicineSideEffect to the database. Throws an argument exception if passed data is not valid.
- **EditMedicineSideEffect(int id, CreateMedicineSideEffect createDto, string token)** requires admin role to update an existing MedicineSideEffect in the database. Throws an argument exception if any issue comes up.
- **DeleteMedicineSideEffect(int id, string token)** requires admin role to delete an existing MedicineSideEffect from the database. Throws an exception if anything goes amiss, such as the item not being found.

#### ActiveIngredientAPIHandler
Derived from APIHandlerBase class and uses its constructor to initialize fields.
Methods:
- **GetAll()** requires no authorization and returns an IEnumerable of every ActiveIngredient added to the database.
- **Get(int id)** requires no authorization and returns a single ActiveIngredient from the database that has the given id. If it doesn't exist, it throws an argument exception with the "Not Found" message.
- **CreateActiveIngredient(CreateActiveIngredientDto createDto, string token)** requires admin role to post a ActiveIngredient to the database. If any issues come up (such as validation problems) the function throws an argument exception.
- **EditActiveIngredient(int id, CreateActiveIngredientDto createDto, string token)** requires admin role to update an existing ActiveIngredient in the database. Throws an excetpion if the ActiveIngredient doesn't exist, the user is not authorized or if any other issue comes up.
- **DeleteActiveIngredient(int id, string token)** requires admin role to delete an existing ActiveIngredient from the database. Throws an argument exception if anything goes amiss.

#### MedicineActiveIngredientAPIHandler
Derived from APIHandlerBase class and uses its constructor.
Methods: 
- **GetAll()** requires no authorization and returns an IEnumerable of every MedicineActiveIngredient added to the database, regardless of which medicine it belongs to.
- **Get(int id)** requires no authorization and returns an IEnumerable of every MedicineActiveIngredient that belongs to the medicine with the given id.
- **CreateMedicineActiveIngredient(CreateMedicineActiveIngredient createDto, string token)** requires admin role to post a MedicineActiveIngredient to the database. Throws an argument exception if passed data is not valid.
- **EditMedicineActiveIngredient(int id, CreateMedicineActiveIngredient createDto, string token)** requires admin role to update an existing MedicineActiveIngredient in the database. Throws an argument exception if any issue comes up.
- **DeleteMedicineActiveIngredient(int id, string token)** requires admin role to delete an existing MedicineActiveIngredient from the database. Throws an exception if anything goes amiss, such as the item not being found.

#### RemedyForAPIHandler
Derived from APIHandlerBase class and uses its constructor to initialize fields.
Methods:
- **GetAll()** requires no authorization and returns an IEnumerable of every RemedyFor added to the database.
- **Get(int id)** requires no authorization and returns a single RemedyFor from the database that has the given id. If it doesn't exist, it throws an argument exception with the "Not Found" message.
- **CreateRemedyFor(CreateRemedyForDto createDto, string token)** requires admin role to post a RemedyFor to the database. If any issues come up (such as validation problems) the function throws an argument exception.
- **EditRemedyFor(int id, CreateRemedyForDto createDto, string token)** requires admin role to update an existing RemedyFor in the database. Throws an excetpion if the RemedyFor doesn't exist, the user is not authorized or if any other issue comes up.
- **DeleteRemedyFor(int id, string token)** requires admin role to delete an existing RemedyFor from the database. Throws an argument exception if anything goes amiss.

#### MedicineRemedyForAPIHandler
Derived from APIHandlerBase class and uses its constructor.
Methods: 
- **GetAll()** requires no authorization and returns an IEnumerable of every MedicineRemedyFor added to the database, regardless of which medicine it belongs to.
- **Get(int id)** requires no authorization and returns an IEnumerable of every MedicineRemedyFor that belongs to the medicine with the given id.
- **CreateMedicineRemedyFor(CreateMedicineRemedyFor createDto, string token)** requires admin role to post a MedicineRemedyFor to the database. Throws an argument exception if passed data is not valid.
- **EditMedicineRemedyFor(int id, CreateMedicineRemedyFor createDto, string token)** requires admin role to update an existing MedicineRemedyFor in the database. Throws an argument exception if any issue comes up.
- **DeleteMedicineRemedyFor(int id, string token)** requires admin role to delete an existing MedicineRemedyFor from the database. Throws an exception if anything goes amiss, such as the item not being found.

## WebAPI
### Validators
We use different validators for each model, so we can check if user adds a new item or modifies an existing one in the proper way. Controllers get the validators via dependency injection and validates data passed in body for POST and PUT requests.
#### UserValidator
User validator can be used to validate CreateUserDto object and has the following rules:
- Username needs to be between 6 and 20 characters;
- Username must be unique;
- Username must only consist of digits and letters;
- Password must contain at least one digit, one lowercase letter, one uppercase letter, one special character be at least 8 characters long to make sure its secure enough.
#### PasswordValidator
Password validator can be used to validate a string value and has the following rules:
- Password must contain at least one digit, one lowercase letter, one uppercase letter, one special character be at least 8 characters long to make sure its secure enough.
#### MedicineValidator
Medicine validator can be used to validate CreateMedicineDto and has the following rules:
- Medicine name must be between 5 and 30 characters;
- Medicine's manufacturer name must be between 5 and 30 characters;
- Medicine's package unit must be either mg or ml as we only measure medicine in these two units.
#### ReminderValidator
Reminder validator can be used to validate CreateReminderDto and has the following rules:
- Reminder's DoseMg must be greater than 0 as it would make no sense otherwise;
- Reminder's DoseCount must be greater than 0 as it would make no sense otherwise.

### Controllers
We use controllers for each model to generate endpoints for the API. Controllers handle the proper validation of the data, so they get the matching validator from dependency injection in constructor. As we are aware of different access levels and we have a log in system we assess the required authorization in controllers. Controllers manipulate only their own repository via dependency injection to fulfill single-responsibility.
#### UserController
For UserController we pass the following objects with dependency injection:
- An IItemStore<User> as repository
- A validator for CreateUserDto
- A validator for passwords

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/User | Admin | Empty | Get all users |
| GET | /PillPal/User/{id} | Admin or the requested user | Empty | Get user by id |
| POST | /PillPal/User | None | CreateUserDto which is validated and throws BadRequest if invalid | Registrate new user |
| PUT | /PillPal/User/{id} | Admin or the requested user | CreateUserDto which is validated and throws BadRequest if invalid | Update a user's username or password. If username didn't change, then only validate the password, otherwise validate the new username as well. |
| DELETE | /PillPal/User/{id} | Admin or the requested user | Empty | Remove user by id |
#### LoginController
For LoginController we pass the following objects with dependency injection:
- An IItemStore<User> as repository
- IOptions<JwtOptions> for JwtToken

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| POST | /PillPal/Login | None | CreateUserDto for user login | If username exists and password matches with it, returns a proper JwtToken |
#### MedicineController
For MedicineController we pass the following objects with dependency injection:
- An IItemStore<Medicine> as repository
- A validator for CreateMedicineDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/Medicine | None | Empty | Get all medicines |
| GET | /PillPal/Medicine/{id} | None | Empty | Get medicine by id |
| POST | /PillPal/Medicine | Admin | CreateMedicineDto which is validated and throws BadRequest if invalid | Add new medicine |
| PUT | /PillPal/Medicine/{id} | Admin | CreateMedicineDto which is validated and throws BadRequest if invalid | Update an existing medicine by id |
| DELETE | /PillPal/Medicine/{id} | Admin | Empty | Remove medicine by id |
#### ReminderController
For ReminderController we pass the following objects with dependency injection:
- An IJoinStore<Reminder> as repository
- An IItemStore<User> as repository
- An IItemStore<Medicine> as repository
- A validator for CreateReminderDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/Reminder | Admin | Empty | Get all reminders |
| GET | /PillPal/Reminder/{userid} | Admin or the user with this id | Empty | Get all reminders of the user with this id |
| POST | /PillPal/Reminder | Admin or the user who we post the reminder to | CreateReminderDto which is validated and throws BadRequest if invalid | Check if new reminder is valid and user and medicine both exists, then add the new reminder |
| PUT | /PillPal/Reminder/5 | Admin or the user who the reminder belongs to | CreateReminderDto which is validated and throws BadRequest if invalid | Check if reminder exists and user and medicine also exists, then update the existing reminder |
| DELETE | /PillPal/User/5 | Admin or the user who the reminder belongs to | Empty | Remove reminder by id |

### Repositories
Repositories are only responsible for the accessible methods of a model. They all manipulate a single DataStore passed by dependency injection. All repositories are implementing one of the following interfaces: IJoinStore<T>, IItemStore<T>.
#### UserRepository
Implements IItemStore<User> with the following methods:
- **Add(User item)** add user to the DataStore Users IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove user with id from DataStore Users IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns user by id if exists in DataStore Users IDCollection using indexer.
- **GetAll()** returns all users of DataStore Users IDCollection.
- **Update(User item)** modify existing user with the same id in DataStore Users IDCollection. Returns true on success and false on fail.
#### MedicineRepository
Implements IItemStore<Medicine> with the following methods:
- **Add(Medicine item)** add medicine to the DataStore Medicines IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove medicine with id from DataStore Medicines IDCollection. Returns true on success and false on fail.
- **Update(Medicine item)** modify existing medicine with the same id in DataStore Medicines IDCollection. Returns true on success and false on fail.
- **GetAll()** returns all medicine of DataStore Medicines IDCollection.
- **Get(int id)** returns medicine by id if exists in DataStore Medicines IDCollection using indexer.
#### ReminderRepository
Implements IJoinStore<Reminder> with the following methods:
- **Add(Reminder item)** add reminder to the DataStore Reminders IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove reminder with id from DataStore Reminders IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns reminders where UserId is the given id in DataStore Reminders IDCollection.
- **GetAll()** returns all reminders of DataStore Reminders IDCollection.
- **Update(Reminder item)** modify existing reminder with the same id in DataStore Reminders IDCollection. Returns true on success and false on fail.

### Interface hierarchy
#### IBaseStore<T>
First of all, we have an IBaseStore<T> generic interface which has four methods. These methods are implemented by all the repositories. The generic type is IIdentified, which means it has an Id property.
- **GetAll()** returns all items of the generic type.
- **Add(T item)** tries to add an item to the repository of the generic type; returns true if it was successful and false if not.
- **Update(T item)** tries to modify the item (with the same id) in the repository of the generic type; returns true if it was successful and false if not.
- **Delete(int id)** tries to remove the item (with the given id) in the repository of the generic type; return true if it was successful and false if not.
#### IItemStore<T>
This interface inherits from the IBaseStore<T>. IItemStore<T> is implemented by repositories which only deal with a single model and doesn't need to join tables together.
- **Get(int id)** returns the item of with the same id; if item doesn't exist, returns null.
#### IJoinStore<T>
This interface inherits from the IBaseStore<T>. IJoinStore<T> is implemented by repositories which deal with join tables, so its Get method acts a bit differently.
- **Get(int id)** returns all the items with the given id as it is a many-to-many connection.

### DataStore
This class stores all the data. It has an IDCollection for each table of the database. Using the DatabaseContext object passed in the constructor it initializes the IDCollections with the DbSet<T> objects of the DatabaseContext.

### IDCollection
A generic collection which manipulates the data using the DbSet<T> object passed in its constructor. This is the closest class to the database as it directly handles DbSet<T> objects. Its generic type must be a class, which implements IIdentified, so it has an Id property. It has the folllowing methods and properties:
- **Values** is a property which gives back all items from the database table of the generic type as an IEnumerable<T>. We forbid tracking as this auto-tracking can easily cause many "invisible" issues. Returned items are ordered by id.
- **Size** property which gives back the number of items in a table as an integer.
- **Remove(int id)** at first, the method checks if the item (with the given id) exists and returns false instantly if not; then it removes the item from the DbSet<T> and save the changes to its context. If the process was successful, it returns true.
- **Add(T item)** first of all, it checks if the item with this id already exists and returns false if the given item's id is already used; if it's unique, the method adds the given item to the DbSet<T> and saves the changes of its context. If the method was successful, it returns true.
- **Replace(T item)** firstly, it checks if the item with this id exists and returns false if no item found; if item exists, the method updates it with the data of the given item via the DbSet<T> and saves the changes of its context. If the method was successful, it returns true.
- **Indexer** returns the item with the given id or null if it's not found.
