# PillPal Documentation

## Summary
Most elderly people faces the difficulties of managing vast variety of medicines, creating the proper schedule for them, keep in mind all the descriptions and not to forget taking them. That's the problem we are aiming to solve or at least provide a tool to make it easier.
Our solution consists of a WebAPI, a Class Library, a MAUI App and a WebApplication. In the following we are going to break them down into smaller segments and introduce their details.

## Class Library
### User
User class consists of Id, Username and Password properties. Our password is a byte array which is generated by hashing the string type password given via constructor. For hashing we're using a unique salt so it gives more security. User class also has a Matches(string password) function for checking if the given password is the same as the user's byte[] password after hashing. We've made 3 constructors: one for logging in, one for JsonConstructor and one for the controller for registering a new user.
### Medicine
Medicine class consists of Id, Name, Description, Manufacturer, PackageUnit, PackageSizes, SideEffects, ActiveIngredients and RemedyForAilments properties. PackageUnit stores the unit of the medicine's PackageSizes which is either "ml" or "mg". PackageSizes, SideEffects, ActiveIngredients and RemedyForAilments are multi-valued fields so they have a separate table and joined together with medicine. Medicine class has 2 constructors: one JsonConstructor with id and one constructor without id. Multi-valued fields are set from outside and not from constructor.
### Reminder
Reminder table is a join-table itself so its class behaves the same way. It has the following properties: Id, UserId, User, MedicineId, Medicine, When, DoseCount, DoseMg, TakingMethod. User and Medicine properties are nullable as they're set from outside based on UserId and MedicineId. DoseCount stores the quantity to take in and TakingMethod stores how to take it in. 
### ExceptionHandler
Our main issue with HttpResponseMessage is that we have a wide range of different structures for different error messages. We created a CheckHttpResponse(HttpResponseMessage message) static method which handles each HttpResponseMessage properly and throws an ArgumentException with the proper error message if the request failed for any reasons. With this static method we can easily handle any error message generally.

### API handlers
For handling different request towards the API from the backend we created API handlers to make it easier and avoid code repeating. They also handle different occuring issues and throws exception with the proper error message.
#### MedicineAPIHandler
Through constructor base url and HttpClient can be passed to make testing easier for us. If HttpClient is not given then it is created with the base url.
Methods: 
- **GetMedicine(int id)** method which gives back the medicine with the given id. And throws exception if something goes wrong.
- **GetMedicines()** method returns all the medicines. Throws exception in case of any issue.
- **CreateMedicine(MedicineDto medicine, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin to access posting; Then posts the serialized Medicine object. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **UpdateMedicine(int id, MedicineDto medicine, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin to access putting; Then puts the serialized Medicine object to the given id. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **DeleteMedicine(int id, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin to access deleting; Then deletes the medicine with the given id. In case of any issues function throws exception (usually it somehow connects to authorization).
#### ReminderAPIHandler
Through constructor base url and HttpClient can be passed to make testing easier for us. If HttpClient is not given then it is created with the base url.
Methods: 
- **Get(int id, string auth)** method sets authorization in header, then gives back all reminders for the user with the given id. Needs authentication as a user can only access their own reminders. And throws exception if something goes wrong (usually connected to authorization).
- **GetAll(string auth)** method sets authorization in header, then returns all reminders. Needs admin authentication as users' reminders are sensitive data. Throws exception in case of any issue (usually connected to authorization).
- **CreateReminder(ReminderDto reminder, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user who the reminder belongs to for access of posting; Then posts the serialized Reminder object. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **EditReminder(int id, RemiderDto reminder, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user who the reminder belongs to for access of putting; Then puts the serialized Reminder object to the user with given id. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **DeleteMedicine(int id, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user who the reminder belongs to for access of deleting; Then deletes the reminder with the given id. In case of any issues function throws exception (usually it somehow connects to authorization).
#### UserAPIHandler
Through constructor base url and HttpClient can be passed to make testing easier for us. If HttpClient is not given then it is created with the base url.
Methods: 
- **Login(CreateUserDto user)** method which posts a login with the given username and password, then returns the bearer token on success.
- **GetUser(int id, string auth)** method sets given authentication in header as you need to be admin or the user themself who's data is accessed. Returns the user with the given id. Throws error if something goes wrong with the request. 
- **GetUsers(string auth)** method sets given authentication in header as you need to be admin to access all users. Returns all users' data. Throws exception in case of any issue.
- **CreateUser(CreateUserDto user)** void method posts the serialized User object, this way user can registrate a new account. In case of any issues function throws exception (usually it somehow connects to validation).
- **UpdateUser(int id, CreateUserDto user, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user themself to access putting; Then puts the serialized User object to the given id. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **DeleteUser(int id, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user themself to access deleting; Then deletes the user with the given id. In case of any issues function throws exception (usually it somehow connects to authorization).

## WebAPI
### Controllers
We use controllers for each model to generate endpoints for the API. Controllers handle the proper validation of the data, so they get the matching validator from dependency injection in constructor. As we are aware of different access levels and we have a log in system we assess the required authorization in controllers. Controllers manipulate only their own repository via dependency injection to fulfill single-responsibility.
#### UserController
For UserController we pass the following objects with dependency injection:
- An IItemStore<User> as repository
- A validator for CreateUserDto
- A validator for passwords

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/User | Admin | Empty | Get all users |
| GET | /PillPal/User/{id} | Admin or the requested user | Empty | Get user by id |
| POST | /PillPal/User | None | CreateUserDto which is validated and throws BadRequest if invalid | Registrate new user |
| PUT | /PillPal/User/{id} | Admin or the requested user | CreateUserDto which is validated and throws BadRequest if invalid | Update a user's username or password. If username didn't change, then only validate the password, otherwise validate the new username as well. |
| DELETE | /PillPal/User/{id} | Admin or the requested user | Empty | Remove user by id |
#### LoginController
For LoginController we pass the following objects with dependency injection:
- An IItemStore<User> as repository
- IOptions<JwtOptions> for JwtToken

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| POST | /PillPal/Login | None | CreateUserDto for user login | If username exists and password matches with it, returns a proper JwtToken |
#### MedicineController
For MedicineController we pass the following objects with dependency injection:
- An IItemStore<Medicine> as repository
- A validator for CreateMedicineDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/Medicine | None | Empty | Get all medicines |
| GET | /PillPal/Medicine/{id} | None | Empty | Get medicine by id |
| POST | /PillPal/Medicine | Admin | CreateMedicineDto which is validated and throws BadRequest if invalid | Add new medicine |
| PUT | /PillPal/Medicine/{id} | Admin | CreateMedicineDto which is validated and throws BadRequest if invalid | Update an existing medicine by id |
| DELETE | /PillPal/Medicine/{id} | Admin | Empty | Remove medicine by id |
#### ReminderController
For ReminderController we pass the following objects with dependency injection:
- An IJoinStore<Reminder> as repository
- An IItemStore<User> as repository
- An IItemStore<Medicine> as repository
- A validator for CreateReminderDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/Reminder | Admin | Empty | Get all reminders |
| GET | /PillPal/Reminder/{userid} | Admin or the user with this id | Empty | Get all reminders of the user with this id |
| POST | /PillPal/Reminder | Admin or the user who we post the reminder to | CreateReminderDto which is validated and throws BadRequest if invalid | Check if new reminder is valid and user and medicine both exists, then add the new reminder |
| PUT | /PillPal/Reminder/5 | Admin or the user who the reminder belongs to | CreateReminderDto which is validated and throws BadRequest if invalid | Check if reminder exists and user and medicine also exists, then update the existing reminder |
| DELETE | /PillPal/User/5 | Admin or the user who the reminder belongs to | Empty | Remove reminder by id |

### Repositories
Repositories are only responsible for the accessible methods of a model. They all manipulate a single DataStore passed by dependency injection. All repositories are implementing one of the following interfaces: IJoinStore<T>, IItemStore<T>.

### Interface hierarchy
#### IBaseStore<T>
First of all, we have an IBaseStore<T> generic interface which has four methods. These methods are implemented by all the repositories. The generic type is IIdentified, which means it has an Id property.
- **GetAll()** returns all items of the generic type.
- **Add(T item)** tries to add an item to the repository of the generic type; returns true if it was successful and false if not.
- **Update(T item)** tries to modify the item (with the same id) in the repository of the generic type; returns true if it was successful and false if not.
- **Delete(int id)** tries to remove the item (with the given id) in the repository of the generic type; return true if it was successful and false if not.
#### IItemStore<T>
This interface inherits from the IBaseStore<T>. IItemStore<T> is implemented by repositories which only deal with a single model and doesn't need to join tables together.
- **Get(int id)** returns the item of with the same id; if item doesn't exist, returns null.
#### IJoinStore<T>
This interface inherits from the IBaseStore<T>. IJoinStore<T> is implemented by repositories which deal with join tables, so its Get method acts a bit differently.
- **Get(int id)** returns all the items with the given id as it is a many-to-many connection.

### DataStore
This class stores all the data. It has an IDCollection for each table of the database. Using the DatabaseContext object passed in the constructor it initializes the IDCollections with the DbSet<T> objects of the DatabaseContext.

### IDCollection
A generic collection which manipulates the data using the DbSet<T> object passed in its constructor. This is the closest class to the database as it directly handles DbSet<T> objects. Its generic type must be a class, which implements IIdentified, so it has an Id property. It has the folllowing methods and properties:
- **Values** is a property which gives back all items from the database table of the generic type as an IEnumerable<T>. We forbid tracking as this auto-tracking can easily cause many "invisible" issues. Returned items are ordered by id.
- **Size** property which gives back the number of items in a table as an integer.
- **Remove(int id)** at first, the method checks if the item (with the given id) exists and returns false instantly if not; then it removes the item from the DbSet<T> and save the changes to its context. If the process was successful, it returns true.
- **Add(T item)** first of all, it checks if the item with this id already exists and returns false if the given item's id is already used; if it's unique, the method adds the given item to the DbSet<T> and saves the changes of its context. If the method was successful, it returns true.
- **Replace(T item)** firstly, it checks if the item with this id exists and returns false if no item found; if item exists, the method updates it with the data of the given item via the DbSet<T> and saves the changes of its context. If the method was successful, it returns true.
- **Indexer** returns the item with the given id or null if it's not found.
