# PillPal Documentation

## Summary
Most elderly people faces the difficulties of managing vast variety of medicines, creating the proper schedule for them, keep in mind all the descriptions and not to forget taking them. That's the problem we are aiming to solve or at least provide a tool to make it easier.
Our solution consists of a WebAPI, a Class Library, a MAUI App and a WebApplication. In the following we are going to break them down into smaller segments and introduce their details.

## Class Library
### IIdentified
An interface that contains a single property, Id. This is a base class for all classes used in this project that are stored in the database. This is so that the IDCollection generic class (that requires classes derived from the IIdentified interface) can handle every object stored by the database without the excess repetition of code.     
### User
User class consists of Id, Username and Password properties. Our password is a byte array which is generated by hashing the string type password given via constructor. For hashing we're using a unique salt so it gives more security. User class also has a Matches(string password) function for checking if the given password is the same as the user's byte[] password after hashing. We've made 3 constructors: one for logging in, one for JsonConstructor and one for the controller for registering a new user.
### Medicine
Medicine class consists of Id, Name, Description, Manufacturer, PackageUnit, PackageSizes, SideEffects, ActiveIngredients and RemedyForAilments properties. PackageUnit stores the unit of the medicine's PackageSizes which is either "ml" or "mg". PackageSizes, SideEffects, ActiveIngredients and RemedyForAilments are multi-valued fields so they have a separate table and joined together with medicine. Medicine class has 2 constructors: one JsonConstructor with id and one constructor without id. Multi-valued fields are set from outside and not from constructor.
### Reminder
Reminder table is a join-table itself so its class behaves the same way. It has the following properties: Id, UserId, User, MedicineId, Medicine, When, DoseCount, DoseMg, TakingMethod. User and Medicine properties are nullable as they're set from outside based on UserId and MedicineId. DoseCount stores the quantity to take in and TakingMethod stores how to take it in. 
### PackageSize 
This class, as all other classes, derives from IIdentified. It has three properties: Id, MedicineId and Size. This class serves as a join table for the package sizes of each medicine, and it is from here that each medicine receives its packageSizes.
### SideEffect
Derived from IIdentified. Properties: Id, Effect, MedicineSideEffects and Medicines. The first two properties contain useful data, while the rest are Lists that are required in order for the join table to function properly and connect Medicines with SideEffects. These lists are ignored by the json serializer.
### ActiveIngredient
Derived from IIdentified. Properties: Id, Ingredient, MedicineActiveIngredients and Medicines. The first two properties contain useful data, while the rest are Lists that are required in order for the join table to function properly and connect Medicines with ActiveIngredients. These lists are ignored by the json serializer.
### RemedyFor
Derived from IIdentified. Properties: Id, Ailment, MedicineRemedyForAilments and Medicines. The first two properties contain useful data, while the rest are Lists that are required in order for the join table to function properly and connect Medicines with RemedyFor objects. These lists are ignored by the json serializer.
### MedicineActiveIngredient
Derived from IIdentified. Properties: Id, MedicineId, Medicine, ActiveIngredientId, ActiveIngredient. This class serves as a join table between Medicines and ActiveIngredients. The Medicine and ActiveIngredient properties are navigation properties that are AutoIncluded in the DatabaseContext. 
### MedicineRemedyFor
Derived from IIdentified. Properties: Id, MedicineId, Medicine, RemedyForId, RemedyFor. This class serves as a join table between Medicines and RemedyFor objects. The Medicine and RemedyFor properties are navigation properties that are AutoIncluded in the DatabaseContext. 
### MedicineSideEffect
Derived from IIdentified. Properties: Id, MedicineId, Medicine, SideEffectId, SideEffect. This class serves as a join table between Medicines and SideEffects. The Medicine and SideEffect properties are navigation properties that are AutoIncluded in the DatabaseContext. 
### ExceptionHandler
Our main issue with HttpResponseMessage is that we have a wide range of different structures for different error messages. We created a CheckHttpResponse(HttpResponseMessage message) static method which handles each HttpResponseMessage properly and throws an ArgumentException with the proper error message if the request failed for any reasons. With this static method we can easily handle any error message generally.

### API handlers
For handling different request towards the API from the backend we created API handlers to make it easier and avoid code repeating. They also handle different occuring issues and throws exception with the proper error message.

#### APIHandlerBase
This class serves as a base class for APIHandlers, and thus they are all derived from this class. It includes the HttpClient and JsonSerializerOptions as protected fields, and the constructor (that is the same for every APIHandler class). This reduces code repetition and makes it easier to work with these classes.

#### MedicineAPIHandler
Through constructor base url and HttpClient can be passed to make testing easier for us. If HttpClient is not given then it is created with the base url.
Methods: 
- **GetMedicine(int id)** method which gives back the medicine with the given id. And throws exception if something goes wrong.
- **GetMedicines()** method returns all the medicines. Throws exception in case of any issue.
- **CreateMedicine(MedicineDto medicine, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin to access posting; Then posts the serialized Medicine object. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **UpdateMedicine(int id, MedicineDto medicine, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin to access putting; Then puts the serialized Medicine object to the given id. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **DeleteMedicine(int id, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin to access deleting; Then deletes the medicine with the given id. In case of any issues function throws exception (usually it somehow connects to authorization).
#### ReminderAPIHandler
Through constructor base url and HttpClient can be passed to make testing easier for us. If HttpClient is not given then it is created with the base url.
Methods: 
- **Get(int id, string auth)** method sets authorization in header, then gives back all reminders for the user with the given id. Needs authentication as a user can only access their own reminders. And throws exception if something goes wrong (usually connected to authorization).
- **GetAll(string auth)** method sets authorization in header, then returns all reminders. Needs admin authentication as users' reminders are sensitive data. Throws exception in case of any issue (usually connected to authorization).
- **CreateReminder(ReminderDto reminder, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user who the reminder belongs to for access of posting; Then posts the serialized Reminder object. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **EditReminder(int id, RemiderDto reminder, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user who the reminder belongs to for access of putting; Then puts the serialized Reminder object to the user with given id. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **DeleteMedicine(int id, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user who the reminder belongs to for access of deleting; Then deletes the reminder with the given id. In case of any issues function throws exception (usually it somehow connects to authorization).
#### UserAPIHandler
Through constructor base url and HttpClient can be passed to make testing easier for us. If HttpClient is not given then it is created with the base url.
Methods: 
- **Login(CreateUserDto user)** method which posts a login with the given username and password, then returns the bearer token on success.
- **GetUser(int id, string auth)** method sets given authentication in header as you need to be admin or the user themself who's data is accessed. Returns the user with the given id. Throws error if something goes wrong with the request. 
- **GetUsers(string auth)** method sets given authentication in header as you need to be admin to access all users. Returns all users' data. Throws exception in case of any issue.
- **CreateUser(CreateUserDto user)** void method posts the serialized User object, this way user can registrate a new account. In case of any issues function throws exception (usually it somehow connects to validation).
- **UpdateUser(int id, CreateUserDto user, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user themself to access putting; Then puts the serialized User object to the given id. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **DeleteUser(int id, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user themself to access deleting; Then deletes the user with the given id. In case of any issues function throws exception (usually it somehow connects to authorization).

#### PackageSizeAPIHandler
Derived from APIHandlerBase class and uses its constructor to initialize fields.
Methods:
- **GetAll()** requires no authorization and returns an IEnumerable of every PackageSize added to the database, regardless of which medicine it was added to. 
- **Get(int id)** requires no authorization and returns an IEnumerable of PackageSizes based on the id passed (it filters based on medicineId)
- **CreatePackageSize(CreatePackageSizeDto createDto, string token)** requires admin token to post a PackageSize to the database. Throws an argument exception in case any data given is not appropriate (if the Dto didn't pass the validation test, the user is not authorized or the medicine doesn't exist).
- **EditPackageSize(int id, CreatePackageSizeDto createDto, string token)** requires admin token to update an existing PackageSize in the database. Throws an exception if the PackageSize doesn't exist, the user is not authorized or if any other issue comes up. 
- **DeletePackageSize(int id, string token)** requires admin token to delete an existing PackageSize from the database. Throws an argument exception if anything goes wrong.

#### SideEffectAPIHandler
Derived from APIHandlerBase class and uses its constructor to initialize fields.
Methods:
- **GetAll()** requires no authorization and returns an IEnumerable of every SideEffect added to the database.
- **Get(int id)** requires no authorization and returns a single SideEffect from the database that has the given id. If it doesn't exist, it throws an argument exception with the "Not Found" message.
- **CreateSideEffect(CreateSideEffectDto createDto, string token)** requires admin role to post a SideEffect to the database. If any issues come up (such as validation problems) the function throws an argument exception.
- **EditSideEffect(int id, CreateSideEffectDto createDto, string token)** requires admin role to update an existing SideEffect in the database. Throws an excetpion if the SideEffect doesn't exist, the user is not authorized or if any other issue comes up.
- **DeleteSideEffect(int id, string token)** requires admin role to delete an existing SideEffect from the database. Throws an argument exception if anything goes amiss.

#### MedicineSideEffectAPIHandler
Derived from APIHandlerBase class and uses its constructor.
Methods: 
- **GetAll()** requires no authorization and returns an IEnumerable of every MedicineSideEffect added to the database, regardless of which medicine it belongs to.
- **Get(int id)** requires no authorization and returns an IEnumerable of every MedicineSideEffect that belongs to the medicine with the given id.
- **CreateMedicineSideEffect(CreateMedicineSideEffect createDto, string token)** requires admin role to post a MedicineSideEffect to the database. Throws an argument exception if passed data is not valid.
- **EditMedicineSideEffect(int id, CreateMedicineSideEffect createDto, string token)** requires admin role to update an existing MedicineSideEffect in the database. Throws an argument exception if any issue comes up.
- **DeleteMedicineSideEffect(int id, string token)** requires admin role to delete an existing MedicineSideEffect from the database. Throws an exception if anything goes amiss, such as the item not being found.

#### ActiveIngredientAPIHandler
Derived from APIHandlerBase class and uses its constructor to initialize fields.
Methods:
- **GetAll()** requires no authorization and returns an IEnumerable of every ActiveIngredient added to the database.
- **Get(int id)** requires no authorization and returns a single ActiveIngredient from the database that has the given id. If it doesn't exist, it throws an argument exception with the "Not Found" message.
- **CreateActiveIngredient(CreateActiveIngredientDto createDto, string token)** requires admin role to post a ActiveIngredient to the database. If any issues come up (such as validation problems) the function throws an argument exception.
- **EditActiveIngredient(int id, CreateActiveIngredientDto createDto, string token)** requires admin role to update an existing ActiveIngredient in the database. Throws an excetpion if the ActiveIngredient doesn't exist, the user is not authorized or if any other issue comes up.
- **DeleteActiveIngredient(int id, string token)** requires admin role to delete an existing ActiveIngredient from the database. Throws an argument exception if anything goes amiss.

#### MedicineActiveIngredientAPIHandler
Derived from APIHandlerBase class and uses its constructor.
Methods: 
- **GetAll()** requires no authorization and returns an IEnumerable of every MedicineActiveIngredient added to the database, regardless of which medicine it belongs to.
- **Get(int id)** requires no authorization and returns an IEnumerable of every MedicineActiveIngredient that belongs to the medicine with the given id.
- **CreateMedicineActiveIngredient(CreateMedicineActiveIngredient createDto, string token)** requires admin role to post a MedicineActiveIngredient to the database. Throws an argument exception if passed data is not valid.
- **EditMedicineActiveIngredient(int id, CreateMedicineActiveIngredient createDto, string token)** requires admin role to update an existing MedicineActiveIngredient in the database. Throws an argument exception if any issue comes up.
- **DeleteMedicineActiveIngredient(int id, string token)** requires admin role to delete an existing MedicineActiveIngredient from the database. Throws an exception if anything goes amiss, such as the item not being found.

#### RemedyForAPIHandler
Derived from APIHandlerBase class and uses its constructor to initialize fields.
Methods:
- **GetAll()** requires no authorization and returns an IEnumerable of every RemedyFor added to the database.
- **Get(int id)** requires no authorization and returns a single RemedyFor from the database that has the given id. If it doesn't exist, it throws an argument exception with the "Not Found" message.
- **CreateRemedyFor(CreateRemedyForDto createDto, string token)** requires admin role to post a RemedyFor to the database. If any issues come up (such as validation problems) the function throws an argument exception.
- **EditRemedyFor(int id, CreateRemedyForDto createDto, string token)** requires admin role to update an existing RemedyFor in the database. Throws an excetpion if the RemedyFor doesn't exist, the user is not authorized or if any other issue comes up.
- **DeleteRemedyFor(int id, string token)** requires admin role to delete an existing RemedyFor from the database. Throws an argument exception if anything goes amiss.

#### MedicineRemedyForAPIHandler
Derived from APIHandlerBase class and uses its constructor.
Methods: 
- **GetAll()** requires no authorization and returns an IEnumerable of every MedicineRemedyFor added to the database, regardless of which medicine it belongs to.
- **Get(int id)** requires no authorization and returns an IEnumerable of every MedicineRemedyFor that belongs to the medicine with the given id.
- **CreateMedicineRemedyFor(CreateMedicineRemedyFor createDto, string token)** requires admin role to post a MedicineRemedyFor to the database. Throws an argument exception if passed data is not valid.
- **EditMedicineRemedyFor(int id, CreateMedicineRemedyFor createDto, string token)** requires admin role to update an existing MedicineRemedyFor in the database. Throws an argument exception if any issue comes up.
- **DeleteMedicineRemedyFor(int id, string token)** requires admin role to delete an existing MedicineRemedyFor from the database. Throws an exception if anything goes amiss, such as the item not being found.

## WebAPI
### Validators
We use different validators for each model, so we can check if user adds a new item or modifies an existing one in the proper way. Controllers get the validators via dependency injection and validates data passed in body for POST and PUT requests.
#### UserValidator
User validator can be used to validate CreateUserDto object and has the following rules:
- Username needs to be between 6 and 20 characters;
- Username must be unique;
- Username must only consist of digits and letters;
- Password must contain at least one digit, one lowercase letter, one uppercase letter, one special character be at least 8 characters long to make sure its secure enough.
#### PasswordValidator
Password validator can be used to validate a string value and has the following rules:
- Password must contain at least one digit, one lowercase letter, one uppercase letter, one special character be at least 8 characters long to make sure its secure enough.
#### MedicineValidator
Medicine validator can be used to validate CreateMedicineDto and has the following rules:
- Medicine name must be between 5 and 30 characters;
- Medicine's manufacturer name must be between 5 and 30 characters;
- Medicine's package unit must be either mg or ml as we only measure medicine in these two units.
#### ReminderValidator
Reminder validator can be used to validate CreateReminderDto and has the following rules:
- Reminder's DoseMg must be greater than 0 as it would make no sense otherwise;
- Reminder's DoseCount must be greater than 0 as it would make no sense otherwise.
#### ActiveIngredientValidator
ActiveIngredient validator can be used to validate CreateActiveIngredientDto and has the following rules:
- ActiveIngredient's Ingredient length must be at least 3;
- ActiveIngredient's Ingredient has to be unique in the database.
#### SideEffectValidator
SideEffect validator can be used to validate CreateSideEffectDto and has the following rules:
- SideEffect's Effect length must be at least 3;
- SideEffect's Effect has to be unique in the database.
#### RemedyForValidator
RemedyFor validator can be used to validate CreateRemedyForDto and has the following rules:
- RemedyFor's Ailment length must be at least 3;
- RemedyFor's Ailment has to be unique in the database.
#### PackageSizeValidator
PackageSize validator can be used to validate CreatePackageSizeDto and has the following rules:
- PackageSize's Size must be greater than zero.

### Controllers
We use controllers for each model to generate endpoints for the API. Controllers handle the proper validation of the data, so they get the matching validator from dependency injection in constructor. As we are aware of different access levels and we have a log in system we assess the required authorization in controllers. Controllers manipulate only their own repository via dependency injection to fulfill single-responsibility.
#### UserController
For UserController we pass the following objects with dependency injection:
- An IItemStore<User> as repository
- A validator for CreateUserDto
- A validator for passwords

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/User | Admin | Empty | Get all users |
| GET | /PillPal/User/{id} | Admin or the requested user | Empty | Get user by id |
| POST | /PillPal/User | None | CreateUserDto which is validated and throws BadRequest if invalid | Registrate new user |
| PUT | /PillPal/User/{id} | Admin or the requested user | CreateUserDto which is validated and throws BadRequest if invalid | Update a user's username or password. If username didn't change, then only validate the password, otherwise validate the new username as well. |
| DELETE | /PillPal/User/{id} | Admin or the requested user | Empty | Remove user by id |
#### LoginController
For LoginController we pass the following objects with dependency injection:
- An IItemStore<User> as repository
- IOptions<JwtOptions> for JwtToken

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| POST | /PillPal/Login | None | CreateUserDto for user login | If username exists and password matches with it, returns a proper JwtToken |
#### MedicineController
For MedicineController we pass the following objects with dependency injection:
- An IItemStore<Medicine> as repository
- A validator for CreateMedicineDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/Medicine | None | Empty | Get all medicines |
| GET | /PillPal/Medicine/{id} | None | Empty | Get medicine by id |
| POST | /PillPal/Medicine | Admin | CreateMedicineDto which is validated and throws BadRequest if invalid | Add new medicine |
| PUT | /PillPal/Medicine/{id} | Admin | CreateMedicineDto which is validated and throws BadRequest if invalid | Update an existing medicine by id |
| DELETE | /PillPal/Medicine/{id} | Admin | Empty | Remove medicine by id |
#### ReminderController
For ReminderController we pass the following objects with dependency injection:
- An IJoinStore<Reminder> as repository
- An IItemStore<User> as repository
- An IItemStore<Medicine> as repository
- A validator for CreateReminderDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/Reminder | Admin | Empty | Get all reminders |
| GET | /PillPal/Reminder/{userid} | Admin or the user with this id | Empty | Get all reminders of the user with this id |
| POST | /PillPal/Reminder | Admin or the user who we post the reminder to | CreateReminderDto which is validated and throws BadRequest if invalid | Check if new reminder is valid and user and medicine both exists, then add the new reminder |
| PUT | /PillPal/Reminder/5 | Admin or the user who the reminder belongs to | CreateReminderDto which is validated and throws BadRequest if invalid | Check if reminder exists and user and medicine also exists, then update the existing reminder |
| DELETE | /PillPal/Reminder/5 | Admin or the user who the reminder belongs to | Empty | Remove reminder by id |
#### SideEffectController
For SideEffectController we pass the following objects with dependency injection:
- An IItemStore<SideEffect> as repository
- A validator for CreateSideEffectDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/SideEffect | None | Empty | Get all SideEffects |
| GET | /PillPal/SideEffect/{id} | None | Empty | Get the SideEffect with the given id |
| POST | /PillPal/SideEffect | Admin | CreateSideEffectDto which is validated and throws BadRequest if invalid | Check if new SideEffect is valid, then add the new SideEffect |
| PUT | /PillPal/SideEffect/{id} | Admin | CreateSideEffectDto which is validated and throws BadRequest if invalid | Check if SideEffect exists and the Dto is valid, then update the existing SideEffect |
| DELETE | /PillPal/SideEffect/{id} | Admin | Empty | Remove SideEffect by id |
#### RemedyForController
For RemedyForController we pass the following objects with dependency injection:
- An IItemStore<RemedyFor> as repository
- A validator for CreateRemedyForDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/RemedyFor | None | Empty | Get all RemedyFor objects |
| GET | /PillPal/RemedyFor/{id} | None | Empty | Get the RemedyFor with the given id |
| POST | /PillPal/RemedyFor | Admin | CreateRemedyForDto which is validated and throws BadRequest if invalid | Check if new RemedyFor is valid, then add the new RemedyFor |
| PUT | /PillPal/RemedyFor/{id} | Admin | CreateRemedyForDto which is validated and throws BadRequest if invalid | Check if RemedyFor exists and the Dto is valid, then update the existing RemedyFor |
| DELETE | /PillPal/RemedyFor/{id} | Admin | Empty | Remove RemedyFor by id |
#### ActiveIngredientController
For ActiveIngredientController we pass the following objects with dependency injection:
- An IItemStore<ActiveIngredient> as repository
- A validator for CreateActiveIngredientDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/ActiveIngredient | None | Empty | Get all ActiveIngredients |
| GET | /PillPal/ActiveIngredient/{id} | None | Empty | Get the ActiveIngredient with the given id |
| POST | /PillPal/ActiveIngredient | Admin | CreateActiveIngredientDto which is validated and throws BadRequest if invalid | Check if new ActiveIngredient is valid, then add the new ActiveIngredient |
| PUT | /PillPal/ActiveIngredient/{id} | Admin | CreateActiveIngredientDto which is validated and throws BadRequest if invalid | Check if ActiveIngredient exists and the Dto is valid, then update the existing ActiveIngredient |
| DELETE | /PillPal/ActiveIngredient/{id} | Admin | Empty | Remove ActiveIngredient by id |
#### PackageSizeController
For PackageSizeController we pass the following objects with dependency injection:
- An IJoinStore<PackageSize> as repository
- An IItemStore<Medicine> as repository
- A validator for CreatePackageSizeDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/PackageSize | None | Empty | Get all PackageSizes |
| GET | /PillPal/PackageSize/{id} | None | Empty | Get the PackageSizes that belong to the medicine with the given id |
| POST | /PillPal/PackageSize | Admin | CreatePackageSizeDto which is validated and throws BadRequest if invalid | Check if new PackageSize is valid and whether medicine exists, then add the new PackageSize |
| PUT | /PillPal/PackageSize/{id} | Admin | CreatePackageSizeDto which is validated and throws BadRequest if invalid | Check if both PackageSize and medicine exist and the Dto is valid, then update the existing PackageSize |
| DELETE | /PillPal/PackageSize/{id} | Admin | Empty | Remove PackageSize by id |
#### MedicineActiveIngredientController
For MedicineActiveIngredientController we pass the following objects with dependency injection:
- An IJoinStore<MedicineActiveIngredient> as repository
- An IItemStore<Medicine> as repository
- An IItemStore<ActiveIngredient> as repository

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/MedicineActiveIngredient | None | Empty | Get all MedicineActiveIngredients |
| GET | /PillPal/MedicineActiveIngredient/{id} | None | Empty | Get the MedicineActiveIngredients that belong to the medicine with the given id |
| POST | /PillPal/MedicineActiveIngredient | Admin | CreateMedicineActiveIngredientDto | Check if both ActiveIngredient and Medicine exist, then add the new MedicineActiveIngredient |
| PUT | /PillPal/MedicineActiveIngredient/{id} | Admin | CreateMedicineActiveIngredientDto | Check if MedicineActiveIngredient, ActiveIngredient and Medicine all exist, then update the existing MedicineActiveIngredient |
| DELETE | /PillPal/MedicineActiveIngredient/{id} | Admin | Empty | Remove MedicineActiveIngredient by id |
#### MedicineSideEffectController
For MedicineSideEffectController we pass the following objects with dependency injection:
- An IJoinStore<MedicineSideEffect> as repository
- An IItemStore<Medicine> as repository
- An IItemStore<SideEffect> as repository

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/MedicineSideEffect | None | Empty | Get all MedicineSideEffects |
| GET | /PillPal/MedicineSideEffect/{id} | None | Empty | Get the MedicineSideEffects that belong to the medicine with the given id |
| POST | /PillPal/MedicineSideEffect | Admin | CreateMedicineSideEffectDto | Check if both SideEffect and Medicine exist, then add the new MedicineSideEffect |
| PUT | /PillPal/MedicineSideEffect/{id} | Admin | CreateMedicineSideEffectDto | Check if MedicineSideEffect, SideEffect and Medicine all exist, then update the existing MedicineSideEffect |
| DELETE | /PillPal/MedicineSideEffect/{id} | Admin | Empty | Remove MedicineSideEffect by id |
#### MedicineRemedyForController
For MedicineRemedyForController we pass the following objects with dependency injection:
- An IJoinStore<MedicineRemedyFor> as repository
- An IItemStore<Medicine> as repository
- An IItemStore<RemedyFor> as repository

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/MedicineRemedyFor | None | Empty | Get all MedicineRemedyFor objects |
| GET | /PillPal/MedicineRemedyFor/{id} | None | Empty | Get the MedicineRemedyFor objects that belong to the medicine with the given id |
| POST | /PillPal/MedicineRemedyFor | Admin | CreateMedicineRemedyForDto | Check if both RemedyFor and Medicine exist, then add the new MedicineRemedyFor |
| PUT | /PillPal/MedicineRemedyFor/{id} | Admin | CreateMedicineRemedyForDto | Check if MedicineRemedyFor, RemedyFor and Medicine all exist, then update the existing MedicineRemedyFor |
| DELETE | /PillPal/MedicineRemedyFor/{id} | Admin | Empty | Remove MedicineRemedyFor by id |

### Repositories
Repositories are only responsible for the accessible methods of a model. They all manipulate a single DataStore passed by dependency injection. All repositories are implementing one of the following interfaces: IJoinStore<T>, IItemStore<T>.
#### UserRepository
Implements IItemStore<User> with the following methods:
- **Add(User item)** add user to the DataStore Users IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove user with id from DataStore Users IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns user by id if exists in DataStore Users IDCollection using indexer.
- **GetAll()** returns all users of DataStore Users IDCollection.
- **Update(User item)** modify existing user with the same id in DataStore Users IDCollection. Returns true on success and false on fail.
#### MedicineRepository
Implements IItemStore<Medicine> with the following methods:
- **Add(Medicine item)** add medicine to the DataStore Medicines IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove medicine with id from DataStore Medicines IDCollection. Returns true on success and false on fail.
- **Update(Medicine item)** modify existing medicine with the same id in DataStore Medicines IDCollection. Returns true on success and false on fail.
- **GetAll()** returns all medicine of DataStore Medicines IDCollection.
- **Get(int id)** returns medicine by id if exists in DataStore Medicines IDCollection using indexer.
#### ReminderRepository
Implements IJoinStore<Reminder> with the following methods:
- **Add(Reminder item)** add reminder to the DataStore Reminders IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove reminder with id from DataStore Reminders IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns reminders where UserId is the given id in DataStore Reminders IDCollection.
- **GetAll()** returns all reminders of DataStore Reminders IDCollection.
- **Update(Reminder item)** modify existing reminder with the same id in DataStore Reminders IDCollection. Returns true on success and false on fail.
#### PackageSizeRepository
Implements IJoinStore<PackageSize> with the following methods:
- **Add(PackageSize item)** add packageSize to the DataStore's PackageSizes IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove packageSize with id from DataStore's PackageSizes IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns packageSizes where MedicineId is the given id in DataStore's PackageSizes IDCollection.
- **GetAll()** returns all packageSizes of DataStore's PackageSizes IDCollection.
- **Update(PackageSize item)** modify existing PackageSize with the same id in DataStore's PackageSizes IDCollection. Returns true on success and false on fail.
#### MedicineSideEffectRepository
Implements IJoinStore<MedicineSideEffect> with the following methods:
- **Add(MedicineSideEffect item)** add MedicineSideEffect to the DataStore's MedicineSideEffects IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove MedicineSideEffect with id from DataStore's MedicineSideEffects IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns MedicineSideEffects where MedicineId is the given id in DataStore's MedicineSideEffects IDCollection.
- **GetAll()** returns all MedicineSideEffects of DataStore's MedicineSideEffects IDCollection.
- **Update(MedicineSideEffect item)** modify existing MedicineSideEffect with the same id in DataStore's MedicineSideEffects IDCollection. Returns true on success and false on fail.
#### MedicineActiveIngredientRepository
Implements IJoinStore<MedicineActiveIngredient> with the following methods:
- **Add(MedicineActiveIngredient item)** add MedicineActiveIngredient to the DataStore's MedicineActiveIngredients IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove MedicineActiveIngredient with id from DataStore's MedicineActiveIngredients IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns MedicineActiveIngredients where MedicineId is the given id in DataStore's MedicineActiveIngredients IDCollection.
- **GetAll()** returns all MedicineActiveIngredients of DataStore's MedicineActiveIngredients IDCollection.
- **Update(MedicineActiveIngredient item)** modify existing MedicineActiveIngredient with the same id in DataStore's MedicineActiveIngredients IDCollection. Returns true on success and false on fail.
#### MedicineRemedyForRepository
Implements IJoinStore<MedicineRemedyFor> with the following methods:
- **Add(MedicineRemedyFor item)** add MedicineRemedyFor to the DataStore's MedicineRemedyForAilments IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove MedicineRemedyFor with id from DataStore's MedicineRemedyForAilments IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns MedicineRemedyFor objects where MedicineId is the given id in DataStore's MedicineRemedyForAilments IDCollection.
- **GetAll()** returns all MedicineRemedyFor objects of DataStore's MedicineRemedyForAilments IDCollection.
- **Update(MedicineRemedyFor item)** modify existing MedicineRemedyFor with the same id in DataStore's MedicineRemedyForAilments IDCollection. Returns true on success and false on fail.
#### SideEffectRepository
Implements IItemStore<SideEffect> with the following methods:
- **Add(SideEffect item)** add SideEffect to the DataStore's SideEffects IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove SideEffect with id from DataStore's SideEffects IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns SideEffect where Id is the given id in DataStore's SideEffects IDCollection.
- **GetAll()** returns all SideEffects of DataStore's SideEffects IDCollection.
- **Update(SideEffect item)** modify existing SideEffect with the same id in DataStore's SideEffects IDCollection. Returns true on success and false on fail.
#### ActiveIngredientRepository
Implements IItemStore<ActiveIngredient> with the following methods:
- **Add(ActiveIngredient item)** add ActiveIngredient to the DataStore's ActiveIngredients IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove ActiveIngredient with id from DataStore's ActiveIngredients IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns ActiveIngredient where Id is the given id in DataStore's ActiveIngredients IDCollection.
- **GetAll()** returns all ActiveIngredients of DataStore's ActiveIngredients IDCollection.
- **Update(ActiveIngredient item)** modify existing ActiveIngredient with the same id in DataStore's ActiveIngredients IDCollection. Returns true on success and false on fail.
#### RemedyForRepository
Implements IItemStore<RemedyFor> with the following methods:
- **Add(RemedyFor item)** add RemedyFor to the DataStore's RemedyForAilments IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove RemedyFor with id from DataStore's RemedyForAilments IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns RemedyFor where Id is the given id in DataStore's RemedyForAilments IDCollection.
- **GetAll()** returns all RemedyFor objects of DataStore's RemedyForAilments IDCollection.
- **Update(RemedyFor item)** modify existing RemedyFor with the same id in DataStore's RemedyForAilments IDCollection. Returns true on success and false on fail.

### Interface hierarchy
#### IBaseStore<T>
First of all, we have an IBaseStore<T> generic interface which has four methods. These methods are implemented by all the repositories. The generic type is IIdentified, which means it has an Id property.
- **GetAll()** returns all items of the generic type.
- **Add(T item)** tries to add an item to the repository of the generic type; returns true if it was successful and false if not.
- **Update(T item)** tries to modify the item (with the same id) in the repository of the generic type; returns true if it was successful and false if not.
- **Delete(int id)** tries to remove the item (with the given id) in the repository of the generic type; return true if it was successful and false if not.
#### IItemStore<T>
This interface inherits from the IBaseStore<T>. IItemStore<T> is implemented by repositories which only deal with a single model and doesn't need to join tables together.
- **Get(int id)** returns the item of with the same id; if item doesn't exist, returns null.
#### IJoinStore<T>
This interface inherits from the IBaseStore<T>. IJoinStore<T> is implemented by repositories which deal with join tables, so its Get method acts a bit differently.
- **Get(int id)** returns all the items with the given id as it is a many-to-many connection.

### DataStore
This class stores all the data. It has an IDCollection for each table of the database. Using the DatabaseContext object passed in the constructor it initializes the IDCollections with the DbSet<T> objects of the DatabaseContext.

### IDCollection
A generic collection which manipulates the data using the DbSet<T> object passed in its constructor. This is the closest class to the database as it directly handles DbSet<T> objects. Its generic type must be a class, which implements IIdentified, so it has an Id property. It has the folllowing methods and properties:
- **Values** is a property which gives back all items from the database table of the generic type as an IEnumerable<T>. We forbid tracking as this auto-tracking can easily cause many "invisible" issues. Returned items are ordered by id.
- **Size** property which gives back the number of items in a table as an integer.
- **Remove(int id)** at first, the method checks if the item (with the given id) exists and returns false instantly if not; then it removes the item from the DbSet<T> and save the changes to its context. If the process was successful, it returns true.
- **Add(T item)** first of all, it checks if the item with this id already exists and returns false if the given item's id is already used; if it's unique, the method adds the given item to the DbSet<T> and saves the changes of its context. If the method was successful, it returns true.
- **Replace(T item)** firstly, it checks if the item with this id exists and returns false if no item found; if item exists, the method updates it with the data of the given item via the DbSet<T> and saves the changes of its context. If the method was successful, it returns true.
- **Indexer** returns the item with the given id or null if it's not found.
