# PillPal Documentation

## Summary
Most elderly people face the difficulties of managing vast variety of medicines, creating the proper schedule for them, keep in mind all the descriptions and not to forget taking them. That's the problem we are aiming to solve or at least provide a tool to make it easier.
Our solution consists of a WebAPI, a Class Library, a MAUI App and a WebApplication. In the following we are going to break them down into smaller segments and introduce their details.

## Class Library
### IIdentified
An interface that contains a single property, Id. This is a base class for all classes used in this project that are stored in the database. This is so that the IDCollection generic class (that requires classes derived from the IIdentified interface) can handle every object stored by the database without the excess repetition of code.     
### User
User class consists of Id, Username and Password properties. Our password is a byte array which is generated by hashing the string type password given via constructor. For hashing we're using a unique salt so it gives more security. User class also has a Matches(string password) function for checking if the given password is the same as the user's byte[] password after hashing. We've made 3 constructors: one for logging in, one for JsonConstructor and one for the controller for registering a new user.
### Medicine
Medicine class consists of Id, Name, Description, Manufacturer, PackageUnit, PackageSizes, SideEffects, ActiveIngredients and RemedyForAilments properties. PackageUnit stores the unit of the medicine's PackageSizes which is either "ml" or "mg". PackageSizes, SideEffects, ActiveIngredients and RemedyForAilments are multi-valued fields so they have a separate table and joined together with medicine. Medicine class has 2 constructors: one JsonConstructor with id and one constructor without id. Multi-valued fields are set from outside and not from constructor.
### Reminder
Reminder table is a join-table itself so its class behaves the same way. It has the following properties: Id, UserId, User, MedicineId, Medicine, When, DoseCount, TakingMethod. User and Medicine properties are nullable as they're set from outside based on UserId and MedicineId. DoseCount stores the quantity to take in and TakingMethod stores how to take it in. 
### PackageSize 
This class, as all other classes, derives from IIdentified. It has three properties: Id, MedicineId and Size. This class serves as a join table for the package sizes of each medicine, and it is from here that each medicine receives its packageSizes.
### PackageUnit 
This class, as all other classes, derives from IIdentified. It has two properties: Id and Name. This class is for storing all the PackageUnit from where Medicine gets its unit.
### SideEffect
Derived from IIdentified. Properties: Id, Effect, MedicineSideEffects and Medicines. The first two properties contain useful data, while the rest are Lists that are required in order for the join table to function properly and connect Medicines with SideEffects. These lists are ignored by the json serializer.
### ActiveIngredient
Derived from IIdentified. Properties: Id, Ingredient, MedicineActiveIngredients and Medicines. The first two properties contain useful data, while the rest are Lists that are required in order for the join table to function properly and connect Medicines with ActiveIngredients. These lists are ignored by the json serializer.
### RemedyFor
Derived from IIdentified. Properties: Id, Ailment, MedicineRemedyForAilments and Medicines. The first two properties contain useful data, while the rest are Lists that are required in order for the join table to function properly and connect Medicines with RemedyFor objects. These lists are ignored by the json serializer.
### MedicineActiveIngredient
Derived from IIdentified. Properties: Id, MedicineId, Medicine, ActiveIngredientId, ActiveIngredient. This class serves as a join table between Medicines and ActiveIngredients. The Medicine and ActiveIngredient properties are navigation properties that are AutoIncluded in the DatabaseContext. 
### MedicineRemedyFor
Derived from IIdentified. Properties: Id, MedicineId, Medicine, RemedyForId, RemedyFor. This class serves as a join table between Medicines and RemedyFor objects. The Medicine and RemedyFor properties are navigation properties that are AutoIncluded in the DatabaseContext. 
### MedicineSideEffect
Derived from IIdentified. Properties: Id, MedicineId, Medicine, SideEffectId, SideEffect. This class serves as a join table between Medicines and SideEffects. The Medicine and SideEffect properties are navigation properties that are AutoIncluded in the DatabaseContext. 
### ExceptionHandler
Our main issue with HttpResponseMessage is that we have a wide range of different structures for different error messages. We created a CheckHttpResponse(HttpResponseMessage message) static method which handles each HttpResponseMessage properly and throws an ArgumentException with the proper error message if the request failed for any reasons. With this static method we can easily handle any error message generally.

### API handlers
For handling different request towards the API from the backend we created API handlers to make it easier and avoid code repeating. They also handle different occuring issues and throws exception with the proper error message.

#### APIHandlerBase
This class serves as a base class for APIHandlers, and thus they are all derived from this class. It includes the HttpClient and JsonSerializerOptions as protected fields, and the constructor (that is the same for every APIHandler class). This reduces code repetition and makes it easier to work with these classes.

#### MedicineAPIHandler
Through constructor base url and HttpClient can be passed to make testing easier for us. If HttpClient is not given then it is created with the base url.
Methods: 
- **GetMedicine(int id)** method which gives back the medicine with the given id. And throws exception if something goes wrong.
- **GetMedicines()** method returns all the medicines. Throws exception in case of any issue.
- **CreateMedicine(MedicineDto medicine, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin to access posting; Then posts the serialized Medicine object. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **UpdateMedicine(int id, MedicineDto medicine, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin to access putting; Then puts the serialized Medicine object to the given id. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **DeleteMedicine(int id, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin to access deleting; Then deletes the medicine with the given id. In case of any issues function throws exception (usually it somehow connects to authorization).
#### ReminderAPIHandler
Through constructor base url and HttpClient can be passed to make testing easier for us. If HttpClient is not given then it is created with the base url.
Methods: 
- **Get(int id, string auth)** method sets authorization in header, then gives back all reminders for the user with the given id. Needs authentication as a user can only access their own reminders. And throws exception if something goes wrong (usually connected to authorization).
- **GetAll(string auth)** method sets authorization in header, then returns all reminders. Needs admin authentication as users' reminders are sensitive data. Throws exception in case of any issue (usually connected to authorization).
- **CreateReminder(ReminderDto reminder, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user who the reminder belongs to for access of posting; Then posts the serialized Reminder object. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **EditReminder(int id, RemiderDto reminder, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user who the reminder belongs to for access of putting; Then puts the serialized Reminder object to the user with given id. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **DeleteMedicine(int id, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user who the reminder belongs to for access of deleting; Then deletes the reminder with the given id. In case of any issues function throws exception (usually it somehow connects to authorization).
#### UserAPIHandler
Through constructor base url and HttpClient can be passed to make testing easier for us. If HttpClient is not given then it is created with the base url.
Methods: 
- **Login(CreateUserDto user)** method which posts a login with the given username and password, then returns the bearer token with the user id on success.
- **GetUser(int id, string auth)** method sets given authentication in header as you need to be admin or the user themself who's data is accessed. Returns the user with the given id. Throws error if something goes wrong with the request. 
- **GetUsers(string auth)** method sets given authentication in header as you need to be admin to access all users. Returns all users' data. Throws exception in case of any issue.
- **CreateUser(CreateUserDto user)** void method posts the serialized User object, this way user can registrate a new account. In case of any issues function throws exception (usually it somehow connects to validation).
- **UpdateUser(int id, CreateUserDto user, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user themself to access putting; Then puts the serialized User object to the given id. In case of any issues function throws exception (usually it somehow connects to authorization or validation).
- **DeleteUser(int id, string auth)** void method sets the authorization in the header to the given bearer token as you need to be admin or the user themself to access deleting; Then deletes the user with the given id. In case of any issues function throws exception (usually it somehow connects to authorization).

#### PackageSizeAPIHandler
Derived from APIHandlerBase class and uses its constructor to initialize fields.
Methods:
- **GetAll()** requires no authorization and returns an IEnumerable of every PackageSize added to the database, regardless of which medicine it was added to. 
- **Get(int id)** requires no authorization and returns an IEnumerable of PackageSizes based on the id passed (it filters based on medicineId)
- **CreatePackageSize(CreatePackageSizeDto createDto, string token)** requires admin token to post a PackageSize to the database. Throws an argument exception in case any data given is not appropriate (if the Dto didn't pass the validation test, the user is not authorized or the medicine doesn't exist).
- **EditPackageSize(int id, CreatePackageSizeDto createDto, string token)** requires admin token to update an existing PackageSize in the database. Throws an exception if the PackageSize doesn't exist, the user is not authorized or if any other issue comes up. 
- **DeletePackageSize(int id, string token)** requires admin token to delete an existing PackageSize from the database. Throws an argument exception if anything goes wrong.

#### SideEffectAPIHandler
Derived from APIHandlerBase class and uses its constructor to initialize fields.
Methods:
- **GetAll()** requires no authorization and returns an IEnumerable of every SideEffect added to the database.
- **Get(int id)** requires no authorization and returns a single SideEffect from the database that has the given id. If it doesn't exist, it throws an argument exception with the "Not Found" message.
- **CreateSideEffect(CreateSideEffectDto createDto, string token)** requires admin role to post a SideEffect to the database. If any issues come up (such as validation problems) the function throws an argument exception.
- **EditSideEffect(int id, CreateSideEffectDto createDto, string token)** requires admin role to update an existing SideEffect in the database. Throws an excetpion if the SideEffect doesn't exist, the user is not authorized or if any other issue comes up.
- **DeleteSideEffect(int id, string token)** requires admin role to delete an existing SideEffect from the database. Throws an argument exception if anything goes amiss.

#### MedicineSideEffectAPIHandler
Derived from APIHandlerBase class and uses its constructor.
Methods: 
- **GetAll()** requires no authorization and returns an IEnumerable of every MedicineSideEffect added to the database, regardless of which medicine it belongs to.
- **Get(int id)** requires no authorization and returns an IEnumerable of every MedicineSideEffect that belongs to the medicine with the given id.
- **CreateMedicineSideEffect(CreateMedicineSideEffect createDto, string token)** requires admin role to post a MedicineSideEffect to the database. Throws an argument exception if passed data is not valid.
- **EditMedicineSideEffect(int id, CreateMedicineSideEffect createDto, string token)** requires admin role to update an existing MedicineSideEffect in the database. Throws an argument exception if any issue comes up.
- **DeleteMedicineSideEffect(int id, string token)** requires admin role to delete an existing MedicineSideEffect from the database. Throws an exception if anything goes amiss, such as the item not being found.

#### ActiveIngredientAPIHandler
Derived from APIHandlerBase class and uses its constructor to initialize fields.
Methods:
- **GetAll()** requires no authorization and returns an IEnumerable of every ActiveIngredient added to the database.
- **Get(int id)** requires no authorization and returns a single ActiveIngredient from the database that has the given id. If it doesn't exist, it throws an argument exception with the "Not Found" message.
- **CreateActiveIngredient(CreateActiveIngredientDto createDto, string token)** requires admin role to post a ActiveIngredient to the database. If any issues come up (such as validation problems) the function throws an argument exception.
- **EditActiveIngredient(int id, CreateActiveIngredientDto createDto, string token)** requires admin role to update an existing ActiveIngredient in the database. Throws an excetpion if the ActiveIngredient doesn't exist, the user is not authorized or if any other issue comes up.
- **DeleteActiveIngredient(int id, string token)** requires admin role to delete an existing ActiveIngredient from the database. Throws an argument exception if anything goes amiss.

#### MedicineActiveIngredientAPIHandler
Derived from APIHandlerBase class and uses its constructor.
Methods: 
- **GetAll()** requires no authorization and returns an IEnumerable of every MedicineActiveIngredient added to the database, regardless of which medicine it belongs to.
- **Get(int id)** requires no authorization and returns an IEnumerable of every MedicineActiveIngredient that belongs to the medicine with the given id.
- **CreateMedicineActiveIngredient(CreateMedicineActiveIngredient createDto, string token)** requires admin role to post a MedicineActiveIngredient to the database. Throws an argument exception if passed data is not valid.
- **EditMedicineActiveIngredient(int id, CreateMedicineActiveIngredient createDto, string token)** requires admin role to update an existing MedicineActiveIngredient in the database. Throws an argument exception if any issue comes up.
- **DeleteMedicineActiveIngredient(int id, string token)** requires admin role to delete an existing MedicineActiveIngredient from the database. Throws an exception if anything goes amiss, such as the item not being found.

#### RemedyForAPIHandler
Derived from APIHandlerBase class and uses its constructor to initialize fields.
Methods:
- **GetAll()** requires no authorization and returns an IEnumerable of every RemedyFor added to the database.
- **Get(int id)** requires no authorization and returns a single RemedyFor from the database that has the given id. If it doesn't exist, it throws an argument exception with the "Not Found" message.
- **CreateRemedyFor(CreateRemedyForDto createDto, string token)** requires admin role to post a RemedyFor to the database. If any issues come up (such as validation problems) the function throws an argument exception.
- **EditRemedyFor(int id, CreateRemedyForDto createDto, string token)** requires admin role to update an existing RemedyFor in the database. Throws an excetpion if the RemedyFor doesn't exist, the user is not authorized or if any other issue comes up.
- **DeleteRemedyFor(int id, string token)** requires admin role to delete an existing RemedyFor from the database. Throws an argument exception if anything goes amiss.

#### MedicineRemedyForAPIHandler
Derived from APIHandlerBase class and uses its constructor.
Methods: 
- **GetAll()** requires no authorization and returns an IEnumerable of every MedicineRemedyFor added to the database, regardless of which medicine it belongs to.
- **Get(int id)** requires no authorization and returns an IEnumerable of every MedicineRemedyFor that belongs to the medicine with the given id.
- **CreateMedicineRemedyFor(CreateMedicineRemedyFor createDto, string token)** requires admin role to post a MedicineRemedyFor to the database. Throws an argument exception if passed data is not valid.
- **EditMedicineRemedyFor(int id, CreateMedicineRemedyFor createDto, string token)** requires admin role to update an existing MedicineRemedyFor in the database. Throws an argument exception if any issue comes up.
- **DeleteMedicineRemedyFor(int id, string token)** requires admin role to delete an existing MedicineRemedyFor from the database. Throws an exception if anything goes amiss, such as the item not being found.

### DTOs
In this project we use DTOs solely for the purpose of regulating data that gets posted to the database. To each class that functions as a table in the database belongs a CreateDto. These are in most cases similar to the original class, but the ID property is excluded from all of them (because the ID is assigned by the database). 

#### CreateUserDto
Has only two properties: Username and Password. After posting this to the database, the password gets hashed and is stored in that format for obvious security reasons.

#### CreateReminderDto
This DTO is a bit more complex than the previous one. It consists of two foreign keys (UserId and MedicineId) and four other properties (When, DoseCount, TakingMethod).

#### CreateMedicineDto 
As its name suggests, it is used for creating Medicines. Consists of four properties (Name, Description, PackageUnitId, Manufacturer).

#### CreateSideEffectDto
Since SideEffect objects are quite simple, this class is only made up of a single property, Effect.

#### CreateMedicineSideEffectDto
This class is used to create a join table entry that joins a SideEffect and a Medicine together. For that exact reason, it has two properties: MedicineId and SideEffectId.

#### CreateActiveIngredientDto
Has a single property: Ingredient.

#### CreateMedicineActiveIngredientDto
Used to join an ActiveIngredient and a Medicine together, as a join table entry. Consists of two properties: MedicineId and ActiveIngredientId

#### CreateRemedyForDto
Used to create an entry for the RemedyFor table. Has a single property (Ailment).

#### CreateMedicineRemedyForDto
Used to create a join table entry for the MedicineRemedyFor table, which joins together a Medicine and a RemedyFor. Properties: MedicineId, RemedyForId.

#### CreatePackageSizeDto
This class is different from the rest of the join table classes, because it doesn't join two tables together, only complements data to the Medicine table. Properties: MedicineId, Size.

#### CreatePackageUnitDto
This class is joined to the Medicine in one-to-many relation with each Medicine only having one PackageUnit. Properties: Name.

## WebAPI
### Validators
We use different validators for each model, so we can check if user adds a new item or modifies an existing one in the proper way. Controllers get the validators via dependency injection and validates data passed in body for POST and PUT requests.
#### UserValidator
User validator can be used to validate CreateUserDto object and has the following rules:
- Username needs to be between 6 and 20 characters;
- Username must be unique;
- Username must only consist of digits and letters;
- Password must contain at least one digit, one lowercase letter, one uppercase letter, one special character and be at least 8 characters long to make sure its secure enough.
#### PasswordValidator
Password validator can be used to validate a string value and has the following rules:
- Password must contain at least one digit, one lowercase letter, one uppercase letter, one special character and be at least 8 characters long to make sure its secure enough.
#### MedicineValidator
Medicine validator can be used to validate CreateMedicineDto and has the following rules:
- Medicine name must be between 5 and 30 characters;
- Medicine's manufacturer name must be between 3 and 30 characters;
- Medicine's description needs to be between 5 and 255 characters.
#### ReminderValidator
Reminder validator can be used to validate CreateReminderDto and has the following rules:
- Reminder's DoseCount must be greater than 0 as it would make no sense otherwise.
#### ActiveIngredientValidator
ActiveIngredient validator can be used to validate CreateActiveIngredientDto and has the following rules:
- ActiveIngredient's Ingredient length must be at least 3;
- ActiveIngredient's Ingredient has to be unique in the database.
#### SideEffectValidator
SideEffect validator can be used to validate CreateSideEffectDto and has the following rules:
- SideEffect's Effect length must be at least 3;
- SideEffect's Effect has to be unique in the database.
#### RemedyForValidator
RemedyFor validator can be used to validate CreateRemedyForDto and has the following rules:
- RemedyFor's Ailment length must be at least 3;
- RemedyFor's Ailment has to be unique in the database.
#### PackageSizeValidator
PackageSize validator can be used to validate CreatePackageSizeDto and has the following rules:
- PackageSize's Size must be greater than zero.
- PackageSize needs to be unique per medicine.
#### PackageUnitValidator
PackageUnit validator can be used to validate CreatePackageUnitDto and has the following rules:
- PackageUnit's name needs to be between 1 and 20 characters.

### Controllers
We use controllers for each model to generate endpoints for the API. Controllers handle the proper validation of the data, so they get the matching validator from dependency injection in constructor. As we are aware of different access levels and we have a log in system we assess the required authorization in controllers. Controllers manipulate only their own repository via dependency injection to fulfill single-responsibility.
#### UserController
For UserController we pass the following objects with dependency injection:
- An IItemStore<User> as repository
- A validator for CreateUserDto
- A validator for passwords

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/User | Admin | Empty | Get all users |
| GET | /PillPal/User/{id} | Admin or the requested user | Empty | Get user by id |
| POST | /PillPal/User | None | CreateUserDto which is validated and throws BadRequest if invalid | Registrate new user |
| PUT | /PillPal/User/{id} | Admin or the requested user | CreateUserDto which is validated and throws BadRequest if invalid | Update a user's username or password. If username didn't change, then only validate the password, otherwise validate the new username as well. |
| DELETE | /PillPal/User/{id} | Admin or the requested user | Empty | Remove user by id |
#### LoginController
For LoginController we pass the following objects with dependency injection:
- An IItemStore<User> as repository
- IOptions<JwtOptions> for JwtToken

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| POST | /PillPal/Login | None | CreateUserDto for user login | If username exists and password matches with it, returns a proper JwtToken |
#### MedicineController
For MedicineController we pass the following objects with dependency injection:
- An IItemStore<Medicine> as repository
- A validator for CreateMedicineDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/Medicine | None | Empty | Get all medicines |
| GET | /PillPal/Medicine/{id} | None | Empty | Get medicine by id |
| POST | /PillPal/Medicine | Admin | CreateMedicineDto which is validated and throws BadRequest if invalid | Add new medicine |
| PUT | /PillPal/Medicine/{id} | Admin | CreateMedicineDto which is validated and throws BadRequest if invalid | Update an existing medicine by id |
| DELETE | /PillPal/Medicine/{id} | Admin | Empty | Remove medicine by id |
#### ReminderController
For ReminderController we pass the following objects with dependency injection:
- An IJoinStore<Reminder> as repository
- An IItemStore<User> as repository
- An IItemStore<Medicine> as repository
- A validator for CreateReminderDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/Reminder | Admin | Empty | Get all reminders |
| GET | /PillPal/Reminder/{userid} | Admin or the user with this id | Empty | Get all reminders of the user with this id |
| POST | /PillPal/Reminder | Admin or the user who we post the reminder to | CreateReminderDto which is validated and throws BadRequest if invalid | Check if new reminder is valid and user and medicine both exists, then add the new reminder |
| PUT | /PillPal/Reminder/5 | Admin or the user who the reminder belongs to | CreateReminderDto which is validated and throws BadRequest if invalid | Check if reminder exists and user and medicine also exists, then update the existing reminder |
| DELETE | /PillPal/Reminder/5 | Admin or the user who the reminder belongs to | Empty | Remove reminder by id |
#### SideEffectController
For SideEffectController we pass the following objects with dependency injection:
- An IItemStore<SideEffect> as repository
- A validator for CreateSideEffectDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/SideEffect | None | Empty | Get all SideEffects |
| GET | /PillPal/SideEffect/{id} | None | Empty | Get the SideEffect with the given id |
| POST | /PillPal/SideEffect | Admin | CreateSideEffectDto which is validated and throws BadRequest if invalid | Check if new SideEffect is valid, then add the new SideEffect |
| PUT | /PillPal/SideEffect/{id} | Admin | CreateSideEffectDto which is validated and throws BadRequest if invalid | Check if SideEffect exists and the Dto is valid, then update the existing SideEffect |
| DELETE | /PillPal/SideEffect/{id} | Admin | Empty | Remove SideEffect by id |
#### RemedyForController
For RemedyForController we pass the following objects with dependency injection:
- An IItemStore<RemedyFor> as repository
- A validator for CreateRemedyForDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/RemedyFor | None | Empty | Get all RemedyFor objects |
| GET | /PillPal/RemedyFor/{id} | None | Empty | Get the RemedyFor with the given id |
| POST | /PillPal/RemedyFor | Admin | CreateRemedyForDto which is validated and throws BadRequest if invalid | Check if new RemedyFor is valid, then add the new RemedyFor |
| PUT | /PillPal/RemedyFor/{id} | Admin | CreateRemedyForDto which is validated and throws BadRequest if invalid | Check if RemedyFor exists and the Dto is valid, then update the existing RemedyFor |
| DELETE | /PillPal/RemedyFor/{id} | Admin | Empty | Remove RemedyFor by id |
#### ActiveIngredientController
For ActiveIngredientController we pass the following objects with dependency injection:
- An IItemStore<ActiveIngredient> as repository
- A validator for CreateActiveIngredientDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/ActiveIngredient | None | Empty | Get all ActiveIngredients |
| GET | /PillPal/ActiveIngredient/{id} | None | Empty | Get the ActiveIngredient with the given id |
| POST | /PillPal/ActiveIngredient | Admin | CreateActiveIngredientDto which is validated and throws BadRequest if invalid | Check if new ActiveIngredient is valid, then add the new ActiveIngredient |
| PUT | /PillPal/ActiveIngredient/{id} | Admin | CreateActiveIngredientDto which is validated and throws BadRequest if invalid | Check if ActiveIngredient exists and the Dto is valid, then update the existing ActiveIngredient |
| DELETE | /PillPal/ActiveIngredient/{id} | Admin | Empty | Remove ActiveIngredient by id |
#### PackageSizeController
For PackageSizeController we pass the following objects with dependency injection:
- An IJoinStore<PackageSize> as repository
- An IItemStore<Medicine> as repository
- A validator for CreatePackageSizeDto

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/PackageSize | None | Empty | Get all PackageSizes |
| GET | /PillPal/PackageSize/{id} | None | Empty | Get the PackageSizes that belong to the medicine with the given id |
| POST | /PillPal/PackageSize | Admin | CreatePackageSizeDto which is validated and throws BadRequest if invalid | Check if new PackageSize is valid and whether medicine exists, then add the new PackageSize |
| PUT | /PillPal/PackageSize/{id} | Admin | CreatePackageSizeDto which is validated and throws BadRequest if invalid | Check if both PackageSize and medicine exist and the Dto is valid, then update the existing PackageSize |
| DELETE | /PillPal/PackageSize/{id} | Admin | Empty | Remove PackageSize by id |
#### MedicineActiveIngredientController
For MedicineActiveIngredientController we pass the following objects with dependency injection:
- An IJoinStore<MedicineActiveIngredient> as repository
- An IItemStore<Medicine> as repository
- An IItemStore<ActiveIngredient> as repository

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/MedicineActiveIngredient | None | Empty | Get all MedicineActiveIngredients |
| GET | /PillPal/MedicineActiveIngredient/{id} | None | Empty | Get the MedicineActiveIngredients that belong to the medicine with the given id |
| POST | /PillPal/MedicineActiveIngredient | Admin | CreateMedicineActiveIngredientDto | Check if both ActiveIngredient and Medicine exist, then add the new MedicineActiveIngredient |
| PUT | /PillPal/MedicineActiveIngredient/{id} | Admin | CreateMedicineActiveIngredientDto | Check if MedicineActiveIngredient, ActiveIngredient and Medicine all exist, then update the existing MedicineActiveIngredient |
| DELETE | /PillPal/MedicineActiveIngredient/{id} | Admin | Empty | Remove MedicineActiveIngredient by id |
#### MedicineSideEffectController
For MedicineSideEffectController we pass the following objects with dependency injection:
- An IJoinStore<MedicineSideEffect> as repository
- An IItemStore<Medicine> as repository
- An IItemStore<SideEffect> as repository

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/MedicineSideEffect | None | Empty | Get all MedicineSideEffects |
| GET | /PillPal/MedicineSideEffect/{id} | None | Empty | Get the MedicineSideEffects that belong to the medicine with the given id |
| POST | /PillPal/MedicineSideEffect | Admin | CreateMedicineSideEffectDto | Check if both SideEffect and Medicine exist, then add the new MedicineSideEffect |
| PUT | /PillPal/MedicineSideEffect/{id} | Admin | CreateMedicineSideEffectDto | Check if MedicineSideEffect, SideEffect and Medicine all exist, then update the existing MedicineSideEffect |
| DELETE | /PillPal/MedicineSideEffect/{id} | Admin | Empty | Remove MedicineSideEffect by id |
#### MedicineRemedyForController
For MedicineRemedyForController we pass the following objects with dependency injection:
- An IJoinStore<MedicineRemedyFor> as repository
- An IItemStore<Medicine> as repository
- An IItemStore<RemedyFor> as repository

| Request | URL | Authorization | Body | Description |
| ------- | ------- | ------- | ------- | ------- |
| GET | /PillPal/MedicineRemedyFor | None | Empty | Get all MedicineRemedyFor objects |
| GET | /PillPal/MedicineRemedyFor/{id} | None | Empty | Get the MedicineRemedyFor objects that belong to the medicine with the given id |
| POST | /PillPal/MedicineRemedyFor | Admin | CreateMedicineRemedyForDto | Check if both RemedyFor and Medicine exist, then add the new MedicineRemedyFor |
| PUT | /PillPal/MedicineRemedyFor/{id} | Admin | CreateMedicineRemedyForDto | Check if MedicineRemedyFor, RemedyFor and Medicine all exist, then update the existing MedicineRemedyFor |
| DELETE | /PillPal/MedicineRemedyFor/{id} | Admin | Empty | Remove MedicineRemedyFor by id |

### Repositories
Repositories are only responsible for the accessible methods of a model. They all manipulate a single DataStore passed by dependency injection. All repositories are implementing one of the following interfaces: IJoinStore<T>, IItemStore<T>.
#### UserRepository
Implements IItemStore<User> with the following methods:
- **Add(User item)** add user to the DataStore Users IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove user with id from DataStore Users IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns user by id if exists in DataStore Users IDCollection using indexer.
- **GetAll()** returns all users of DataStore Users IDCollection.
- **Update(User item)** modify existing user with the same id in DataStore Users IDCollection. Returns true on success and false on fail.
#### MedicineRepository
Implements IItemStore<Medicine> with the following methods:
- **Add(Medicine item)** add medicine to the DataStore Medicines IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove medicine with id from DataStore Medicines IDCollection. Returns true on success and false on fail.
- **Update(Medicine item)** modify existing medicine with the same id in DataStore Medicines IDCollection. Returns true on success and false on fail.
- **GetAll()** returns all medicine of DataStore Medicines IDCollection.
- **Get(int id)** returns medicine by id if exists in DataStore Medicines IDCollection using indexer.
#### ReminderRepository
Implements IJoinStore<Reminder> with the following methods:
- **Add(Reminder item)** add reminder to the DataStore Reminders IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove reminder with id from DataStore Reminders IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns reminders where UserId is the given id in DataStore Reminders IDCollection.
- **GetAll()** returns all reminders of DataStore Reminders IDCollection.
- **Update(Reminder item)** modify existing reminder with the same id in DataStore Reminders IDCollection. Returns true on success and false on fail.
#### PackageSizeRepository
Implements IJoinStore<PackageSize> with the following methods:
- **Add(PackageSize item)** add packageSize to the DataStore's PackageSizes IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove packageSize with id from DataStore's PackageSizes IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns packageSizes where MedicineId is the given id in DataStore's PackageSizes IDCollection.
- **GetAll()** returns all packageSizes of DataStore's PackageSizes IDCollection.
- **Update(PackageSize item)** modify existing PackageSize with the same id in DataStore's PackageSizes IDCollection. Returns true on success and false on fail.
#### MedicineSideEffectRepository
Implements IJoinStore<MedicineSideEffect> with the following methods:
- **Add(MedicineSideEffect item)** add MedicineSideEffect to the DataStore's MedicineSideEffects IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove MedicineSideEffect with id from DataStore's MedicineSideEffects IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns MedicineSideEffects where MedicineId is the given id in DataStore's MedicineSideEffects IDCollection.
- **GetAll()** returns all MedicineSideEffects of DataStore's MedicineSideEffects IDCollection.
- **Update(MedicineSideEffect item)** modify existing MedicineSideEffect with the same id in DataStore's MedicineSideEffects IDCollection. Returns true on success and false on fail.
#### MedicineActiveIngredientRepository
Implements IJoinStore<MedicineActiveIngredient> with the following methods:
- **Add(MedicineActiveIngredient item)** add MedicineActiveIngredient to the DataStore's MedicineActiveIngredients IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove MedicineActiveIngredient with id from DataStore's MedicineActiveIngredients IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns MedicineActiveIngredients where MedicineId is the given id in DataStore's MedicineActiveIngredients IDCollection.
- **GetAll()** returns all MedicineActiveIngredients of DataStore's MedicineActiveIngredients IDCollection.
- **Update(MedicineActiveIngredient item)** modify existing MedicineActiveIngredient with the same id in DataStore's MedicineActiveIngredients IDCollection. Returns true on success and false on fail.
#### MedicineRemedyForRepository
Implements IJoinStore<MedicineRemedyFor> with the following methods:
- **Add(MedicineRemedyFor item)** add MedicineRemedyFor to the DataStore's MedicineRemedyForAilments IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove MedicineRemedyFor with id from DataStore's MedicineRemedyForAilments IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns MedicineRemedyFor objects where MedicineId is the given id in DataStore's MedicineRemedyForAilments IDCollection.
- **GetAll()** returns all MedicineRemedyFor objects of DataStore's MedicineRemedyForAilments IDCollection.
- **Update(MedicineRemedyFor item)** modify existing MedicineRemedyFor with the same id in DataStore's MedicineRemedyForAilments IDCollection. Returns true on success and false on fail.
#### SideEffectRepository
Implements IItemStore<SideEffect> with the following methods:
- **Add(SideEffect item)** add SideEffect to the DataStore's SideEffects IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove SideEffect with id from DataStore's SideEffects IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns SideEffect where Id is the given id in DataStore's SideEffects IDCollection.
- **GetAll()** returns all SideEffects of DataStore's SideEffects IDCollection.
- **Update(SideEffect item)** modify existing SideEffect with the same id in DataStore's SideEffects IDCollection. Returns true on success and false on fail.
#### ActiveIngredientRepository
Implements IItemStore<ActiveIngredient> with the following methods:
- **Add(ActiveIngredient item)** add ActiveIngredient to the DataStore's ActiveIngredients IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove ActiveIngredient with id from DataStore's ActiveIngredients IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns ActiveIngredient where Id is the given id in DataStore's ActiveIngredients IDCollection.
- **GetAll()** returns all ActiveIngredients of DataStore's ActiveIngredients IDCollection.
- **Update(ActiveIngredient item)** modify existing ActiveIngredient with the same id in DataStore's ActiveIngredients IDCollection. Returns true on success and false on fail.
#### RemedyForRepository
Implements IItemStore<RemedyFor> with the following methods:
- **Add(RemedyFor item)** add RemedyFor to the DataStore's RemedyForAilments IDCollection. Returns true on success and false on fail.
- **Delete(int id)** remove RemedyFor with id from DataStore's RemedyForAilments IDCollection. Returns true on success and false on fail.
- **Get(int id)** returns RemedyFor where Id is the given id in DataStore's RemedyForAilments IDCollection.
- **GetAll()** returns all RemedyFor objects of DataStore's RemedyForAilments IDCollection.
- **Update(RemedyFor item)** modify existing RemedyFor with the same id in DataStore's RemedyForAilments IDCollection. Returns true on success and false on fail.

### Interface hierarchy
#### IBaseStore<T>
First of all, we have an IBaseStore<T> generic interface which has four methods. These methods are implemented by all the repositories. The generic type is IIdentified, which means it has an Id property.
- **GetAll()** returns all items of the generic type.
- **Add(T item)** tries to add an item to the repository of the generic type; returns true if it was successful and false if not.
- **Update(T item)** tries to modify the item (with the same id) in the repository of the generic type; returns true if it was successful and false if not.
- **Delete(int id)** tries to remove the item (with the given id) in the repository of the generic type; return true if it was successful and false if not.
#### IItemStore<T>
This interface inherits from the IBaseStore<T>. IItemStore<T> is implemented by repositories which only deal with a single model and doesn't need to join tables together.
- **Get(int id)** returns the item of with the same id; if item doesn't exist, returns null.
#### IJoinStore<T>
This interface inherits from the IBaseStore<T>. IJoinStore<T> is implemented by repositories which deal with join tables, so its Get method acts a bit differently.
- **Get(int id)** returns all the items with the given id as it is a many-to-many connection.

### DataStore
This class stores all the data. It has an IDCollection for each table of the database. Using the DatabaseContext object passed in the constructor it initializes the IDCollections with the DbSet<T> objects of the DatabaseContext.

### IDCollection
A generic collection which manipulates the data using the DbSet<T> object passed in its constructor. This is the closest class to the database as it directly handles DbSet<T> objects. Its generic type must be a class, which implements IIdentified, so it has an Id property. It has the folllowing methods and properties:
- **Values** is a property which gives back all items from the database table of the generic type as an IEnumerable<T>. We forbid tracking as this auto-tracking can easily cause many "invisible" issues. Returned items are ordered by id.
- **Size** property which gives back the number of items in a table as an integer.
- **Remove(int id)** at first, the method checks if the item (with the given id) exists and returns false instantly if not; then it removes the item from the DbSet<T> and save the changes to its context. If the process was successful, it returns true.
- **Add(T item)** first of all, it checks if the item with this id already exists and returns false if the given item's id is already used; if it's unique, the method adds the given item to the DbSet<T> and saves the changes of its context. If the method was successful, it returns true.
- **Replace(T item)** firstly, it checks if the item with this id exists and returns false if no item found; if item exists, the method updates it with the data of the given item via the DbSet<T> and saves the changes of its context. If the method was successful, it returns true.
- **Indexer** returns the item with the given id or null if it's not found.

## Admin WebApp
We developed our admin pages with Vue, so the many content is way more visible and it makes the whole medicine editing more accessible for the admin.

### Pages
#### Login page
As the name indicates, this page is made for logging in and gaining access to all the features. To log in to this app, you need to be admin. In case you log out or your page is dynamically deleted, you instantly get back to this page and get redirected to this if you try to get to a page without having an admin account logged in.
#### Users page
This page is for showing all the users and the number of their reminders. The page contains a search bar, so the admin can easily look for specific users by their username. Each user row contains a remove button which removes users from the API and the local store as well.
#### New medicine page
To add new medicines to the database, admin can use this page. The page consists of a simple FormKit form with the proper validations matched with the API. Admin can enter the medicine's name, its manufacturer, a brief description, and choose a package unit from a select field filled by the API's PackageUnits. Clicking on the Add button uploads the new medicine to the API and the local store as well. In case of any API related issues the page throws an alert.
#### Edit medicine page
Admin can use this page in case they need to edit any existing medicines or the relations joined to it. The page contains a search bar where you can search for any medicines by name. The FormKit form is automatically filled. The form has the same fields as the new medicine page (Name, Description, Manufacturer, PackageUnit). Below the form there is a delete button in case admin wants to delete the specific medicine, and a modify button if admin wants to preserve the changes in API. The form validates the data the same way as API does. The page also contains 4 sections for modifying join table data (SideEffect, ActiveIngredient, RemedyFor, PackageSize). Each section has the list of items what the selected medicine has. Each item row has a remove button to delete the relation from the join table. If admin wants to modify an already existing row in the join table, they can simply edit it and it dynamically puts the new data. For the PackageSize the update event is only emitted if the field is unfocused. For every section we put an add button to post a new row to the join table and even push it to the local store. In case something goes wrong (for example caused by improper PackageSize) the page shows an alert to the admin. The selected medicine is binded dynamically to all the sections so if the admin selects other medicine it instantly loads the data joined to that medicine. 
#### New medicine data
This page has four independent sections (PackageUnit, SideEffect, ActiveIngredient, RemedyFor) for editing, creating or deleting data of the table of the specific section. Each section consists of a:
- **Search bar**, so the admin can look for a specific item;
- **Input field**, where the selected item loads and where admin can edit it;
- **Modify button**, which puts the changed data by clicking it;
- **Delete button**, which deletes the specific item from the table;
- **New item part**, which has a field to write the item's name in and an add button to post the new data to the table.
Each new item field has a validation with the proper text length but if something goes wrong and the server throws some unexpected errors (like the data is not unique) the page shows an alert.

### Components
#### BaseHeader
This component is reliable for the navigation of the whole page. It's a sidebar which is collapsable when the resolution is small. In the top left corner the logo of the app is shown even if the sidebar is collapsed. 
#### BaseSpinner
Every time the page waits for data to be pulled it shows up the BaseSpinner so the user will know the page is currently loading data.
#### UserRow
For the user page to show rows of users we made this component. It has a passed property of a user. The row shows the username, the name of reminders of the user and a button to remove it. Clicking on the button asks whether the admin is sure about the deletion.
#### ActiveIngredients
A component containing a list of ActiveIngredientRows to what this parent component passes the loaded activeIngredientOptions for the select field, the currently selected activeIngredient and binds functions to delete emit and update emit of the child. This section also has a button for adding new activeIngredient to the join table. Adding a new row automatically posts it with the first activeIngredientOption's id.
#### ActiveIngredientRow
This component is only a row with 2 FormKit elements. A select for selecting the wanted activeIngredient and a delete button. In case the selected item changes it emits the updateActiveIngredient with the selected item. If the delete button is clicked, this child component emits a deleteActiveIngredient with the item's id, so the parent component can handle it.
#### RemedyFors
A component containing a list of RemedyForRows to what this parent component passes the loaded remedyForOptions for the select field, the currently selected remedyFor and binds functions to delete emit and update emit of the child. This section also has a button for adding new remedyFor to the join table. Adding a new row automatically posts it with the first remedyForOption's id.
#### RemedyForRow
This component is only a row with 2 FormKit elements. A select for selecting the wanted remedyFor and a delete button. In case the selected item changes it emits the updateRemedyFor with the selected item. If the delete button is clicked, this child component emits a deleteRemedyFor with the item's id, so the parent component can handle it.
#### SideEffects
A component containing a list of SideEffectRows to what this parent component passes the loaded sideEffectOptions for the select field, the currently selected sideEffect and binds functions to delete emit and update emit of the child. This section also has a button for adding new sideEffect to the join table. Adding a new row automatically posts it with the first sideEffectOption's id.
#### SideEffectRow
This component is only a row with 2 FormKit elements. A select for selecting the wanted sideEffect and a delete button. In case the selected item changes it emits the updateSideEffect with the selected item. If the delete button is clicked, this child component emits a deleteSideEffect with the item's id, so the parent component can handle it.
#### PackageSizes
A component containing a list of PackageSizeRows to what this parent component passes the currently set packageSize value and binds functions to delete emit and update emit of the child. This section also has a button for adding new packageSuze to the join table. Adding a new row automatically posts it with 1 or the max value of the PackageSizes plus 1. The edit function only updates the table if the value is changed.
#### PackageSizeRow
This component is only a row with 2 FormKit elements. A number input for setting the packageSize and a delete button. In case the number input field is unfocused it emits the updatePackageSize with the changed item. If the delete button is clicked, this child component emits a deletePackageSize with the item's id, so the parent component can handle it.

### Custom styles
#### Coloring
To make coloring of the different elements easier we modified the *tailwind.config.js* and added the colors we decided to use when we were planning the design of the pages. We could also split each color into two other tags to make them easier to set for darkmode.  
#### FormKit design
We extended our *formkit.config.js* to make a consistent and unified design for each and every FormKit element we use in our page.

### Stores
We used pinia stores for each model we wanted to request from API to make it easily accessible for the components and shorten any modifications we need to make on them.
#### ActiveIngredient store
To be able to communicate with the ActiveIngredient endpoint of the API we used the following actions:
- **getActiveIngredients():** this requests all the ActiveIngredients and loads them into the activeIngredients state
- **destroyActiveIngredient(id):** sends a delete request to the API and removes the specific ActiveIngredient from the activeIngredients state as well
- **postActiveIngredient(data):** sends a post request to the API with the new ActiveIngredient data parameter and even push the returned data to the activeIngredients state
- **updateActiveIngredient(id, data):** sends a put request to the API for the specified id with the data parameter and even change the proper object in the activeIngredients state as well
This store also has an activeIngredientOptions getter, so we can easily load all the ActiveIngredients into a select element based on the activeIngredients state.

### Routing

## MAUI Application

The main purpose of our project was the creation of this application. With it, users are able to create reminders for themselves that help them remember to take their medicines. In the following section can be found the description of the application's structure. 

### Appearance & design
#### Themes
Our application implements a dark and a light theme that users can switch between based on their preferences. The files responsible for this are *DarkTheme.xaml* and *LightTheme.xaml*. Each of these files consists of colors with the same list of keys. When a user switches between the two themes, the corresponding color is applied to each component where the color with the given key is used.

#### Custom Styles
In order to reduce code repetition, we used *CustomStyles.xaml* to create design templates for components that can be reused throughout the code. Each of these preset designs has a TargetType (which defines what components it can be applied to) and a Key (by which it can be referred to).

Moreover, we use a custom font called PlayfairDisplay in our application, which is stored in the *Resources/Fonts* folder.

### Components (ContentViews)

There are a number of components that are reused several times throughout the application. These components are  implemented as ContentViews in order to increase their independence and to reduce redundance in our codebase. 

#### PillPal Logo
As this logo is used in almost every single page in our mobile app, we decided to distribute it into a ContentView. This ContentView consists of a frame that is responsible for the background color and the size of the logo and an image of our logo inside it. 

#### ThemeSwitch
This component can be found on the Login, Register and Settings pages, and it is used to switch between the aforementioned dark and light themes. Tied to it is the *ThemeSwitchViewModel*, which is responsible for the logic behind the switch. When this component is loaded, the viewmodel checks if a theme has been saved to the device, and if not, saves the light theme as default. Once the switch is toggled, the **SwitchTheme()** function is called, which replaces the MergedDictionaries of the application and adds the relevant theme, then saves the theme to the device (so that it is stored even when the application is closed).

#### HomeButton
This is used as the navigation menu in our application, and the structure is that of an *Expander*. The header contains the logo, and if clicked, the menu options appear and float out from behind. There are three menu options: New reminder, Home page and Settings. Each of these options is represented with a descriptive icon. When a menu option is clicked, the correlating command in *HomeButtonViewModel* is called, which redirects to the desired page.

#### ReminderCard
This card is used to display reminders on the main screen of our application. On the card, the time of the reminder, the name of the medicine, the dose the user has to take, the taking method and three action buttons can be found. These buttons are used to delete or edit the reminder, or to check the details of the medicine the reminder is bound to. The *ReminderCardViewModel* is responsible for the logic of the component, which confirms the deletion or redirects to the edit or detail pages.


### Pages
#### LoginPage
On the page, the user has the options to switch between themes, log in or go to the registration page. The login process is handled by the *LoginViewModel*, which asks for notification permission (necessary for using the app) and checks if the login data was correct.

#### RegisterPage
This page is very similar to the Login page, as it also has a theme toggle and a similar layout. Furthermore, it gives the ability for the user to register a new account and to go to the login page. The registration is handled by the *RegisterViewModel*, where the username is checked for validity (whether it's taken by already existing users). The the strength of the password and whether it matches the confirmation are also factors that are checked when the user hits registration.

#### MainPage
This is the page where the user's existing reminders are listed using ReminderCards. It's also the page that a user first sees upon logging in (thus the name). The cards are dynamically loaded onto the page thanks to the *MainViewModel*, where the data is requested from the api

#### DetailPage
When a user clicks the info button on a *ReminderCard*, a page pops up with the data of the medicine that belongs to the reminder. On this page, the name, manufacturer, side effects, active ingredients and ailments are visible. The data is loaded in via *DetailPageViewModel*.

#### NewReminderPage
This page is used for creating new reminders. This can be done by clicking the plus icon in the navigation menu, then selecting a medicine that the user wants to set a reminder for, and filling in the necessary data. Once the submit button is pressed, the *NewReminderViewModel* checks for errors, and if all is well, displays a pop-up saying that the upload was successful, then redirects to the main page.

#### EditReminderPage
As the name suggest, this page is used for editing an already existing reminder, and it can be accessed by clicking the edit button on a *ReminderCard*. Similar to how it's done in the new reminder page, the data is checked by a viewmodel (namely *EditReminderViewModel*) before submitting it to the API. Here the user can change the medicine the reminder is bound to, the dose size, the time of the reminder and so on.

#### SettingsPage
Last but not least, we come to the settings. This is the third and final button in the navigation menu, and a user can do three things here: change the application theme, log out or delete their account. The redirection, confirmation pop-up windows and API request are handled by *SettingsPageViewModel*.

